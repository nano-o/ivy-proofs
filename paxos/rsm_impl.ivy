#lang ivy1.7

# Goal: implement a replicated state-machine (RSM) based on Paxos

include order
#include tcp
include udp
include collections

type value_t
instance inst_t: unbounded_sequence

object value_opt_t = {
    type this = struct {
        present : bool,
        value : value_t
    }
}

instance node : iterable
parameter leader : node

object msg_kind = {
    type this = {propose_msg, decision_msg}
}

object msg = {
    type this = struct {
        m_kind : msg_kind,
        m_value : value_t,
        m_index : inst_t
    }
}

instance net : udp_simple(node,msg)

object service_interface(n : node) = {
    export action propose(v:value_t) # the environment, i.e. a client application, calls this
    import action notify_decision(i:inst_t, v:value_t) # this is a call out to the environement
    export action query(i:inst_t) returns (v:value_opt_t) # the environment, i.e. a client application, calls this
    specification {
        relation proposed(V:value_t)
        relation log(I:inst_t,V:value_t)
        invariant log(I,V1) & log(I,V2) -> V1 = V2 #an instruction cannot have more than one distinct value
	after init {
		proposed(V) := false;
		log(I,V) := false;
	}
        before notify_decision {
            require proposed(v);
            require log(i,V) -> V = v;
            log(i,v) := true;
        }
	before propose {
	    proposed(v) := true;
	}
        after query {
            ensure v.present -> log(i,v.value);
        }
    }
    isolate iso = this 
}

instance arr:array(inst_t,value_t)

object service_implementation(self : node) = {
    individual my_log:arr
    after init
    {
	my_log := arr.empty();
    }
    implement service_interface.propose(v:value_t) {
	var m : msg;
        m.m_kind := msg_kind.propose_msg;
        m.m_value := v;
	call net.send(self,leader,m);
    }

    implement net.recv(m:msg) {
	if m.m_kind = msg_kind.propose_msg {
		var i := arr.end(my_log);
       		my_log := arr.append(my_log,m.m_value);
		var mb : msg;
       		mb.m_kind := msg_kind.decision_msg;
       		mb.m_value := m.m_value;
		mb.m_index := i;
		var iter := node.iter.create(0);
            	while ~iter.is_end
            	{
                	var n := iter.val;
                	call net.send(self,n,mb);
               		iter := iter.next;
            	}
	}
	else {
		my_log := arr.resize(my_log,m.m_index + 1,m.m_value);
		call service_interface.notify_decision(self,m.m_index,m.m_value);
	}
    }
    implement service_interface.query(i:inst_t) {
	if i >= arr.end(my_log)
	{
	    v.present := false;
	}
	else
	{
	     v.value := arr.get(my_log,i);
	}
    }
    invariant (service_interface.proposed(self,V) & (arr.value(my_log,I) = V) & (I < arr.end(my_log))) <->  service_interface.log(self,I,V)
    invariant ((arr.value(my_log,I) = V) & (I < arr.end(my_log))) <-> service_interface.log(self,I,V)
}
isolate implementation_iso = this with service_interface, inst_t, arr, net, node
# interpret values as strings:
interpret value_t -> strlit

extract impl(n : node) = service_implementation(n), inst_t, arr, node, net(n)

# generate and compile with `ivyc isolate=impl rsm_impl.ivy`
