#lang ivy1.7

# Goal: implement a replicated state-machine (RSM) based on Paxos

include order
include timeout
include tcp
include collections

type value_t
instance inst_t: unbounded_sequence
instance node : iterable
parameter leader : node
instance arr:array(inst_t,value_t)
instance arr_ack:array(inst_t,node)

object value_opt_t = {
    type this = struct {
        present : bool,
        value : value_t
    }
}

#structure with two elements; 1st : node. 2nd array

object ack_msg_type = { 
    type this = struct {
        val : value_t,
        node_reply : arr_ack
    }
}

instance arr_ackmsg:array(inst_t,ack_msg_type)

object msg_kind = {
    type this = {propose_msg, decision_msg, ack_msg}
}

object msg = {
    type this = struct {
        m_kind : msg_kind,
        m_value : value_t,
        m_index : inst_t,
	m_node : node
    }
}

instance net : simple_tcp(node,msg)

object service_interface(n : node) = {
    export action propose(v:value_t) # the environment, i.e. a client application, calls this
    import action notify_decision(i:inst_t, v:value_t) # this is a call out to the environement
    export action query(i:inst_t) returns (v:value_opt_t) # the environment, i.e. a client application, calls this
    specification {
        relation proposed(V:value_t)
        relation log(I:inst_t,V:value_t)
        invariant log(I,V1) & log(I,V2) -> V1 = V2 #an instruction cannot have more than one distinct value
	after init {
		proposed(V) := false;
		log(I,V) := false;
	}
        before notify_decision {
            require proposed(v);
            require log(i,V) -> V = v;
            log(i,v) := true;
        }
	before propose {
	    proposed(v) := true;
	}
        after query {
            ensure v.present -> log(i,v.value);
        }
    }
    isolate iso = this 
}


object service_implementation(self : node) = {
    
    individual my_log:arr
    individual proposed_log:arr
    individual ack_log:arr_ackmsg
    instance timer : timeout_sec
    import action my_debug_action(i:inst_t)
    import action my_debug_value(v:value_t)
    import action my_debug_node(n:node)
    after init
    {
	my_log := arr.empty;
	proposed_log := arr.empty;
        ack_log := arr_ackmsg.empty;
    }
    implement service_interface.propose(v:value_t) {
	var m : msg;
        m.m_kind := msg_kind.propose_msg;
        m.m_value := v;
	proposed_log := arr.append(proposed_log,v);
	if self = leader {
		#fill up ack_log if proposal comes from leader
		var mack:ack_msg_type;
                mack.val := v;
                mack.node_reply := arr_ack.empty;
                ack_log := arr_ackmsg.append(ack_log,mack);

	};
	call net.send(self,leader,m);
    }

    implement net.recv(m:msg) {
	if m.m_kind = msg_kind.propose_msg {
		var j : inst_t := 0;
		var i : inst_t := arr.end(my_log);
		while j < arr.end(my_log) {
			if arr.get(my_log,j) = m.m_value {
				i := j;
			};
			j := j + 1;
		};
		#call my_debug_action(i);
		if i = arr.end(my_log) {
       			my_log := arr.append(my_log,m.m_value);
		};
		var mb : msg;
       		mb.m_kind := msg_kind.decision_msg;
       		mb.m_value := m.m_value;
		mb.m_index := i;
		#call my_debug_action(mb.m_index);
		var iter := node.iter.create(0);
            	while ~iter.is_end
            	{
                	var n := iter.val;
			if n ~= self {
                		call net.send(self,n,mb);
				#call my_debug_node(n);
				#call my_debug_value(mb.m_value);
			};
               		iter := iter.next;
            	}
	}
	else if m.m_kind = msg_kind.decision_msg {
		var check : bool := false;
		var i : inst_t := 0;
		while i < arr.end(my_log) {
			if arr.get(my_log,i) = m.m_value {
				check := true;
			};
			i := i + 1;
		};
		if check = false {
			my_log := arr.resize(my_log,m.m_index + 1,m.m_value);
			call my_debug_value(m.m_value);

		};
		#Construct ACK msg. send ACK to leader.
		var ma : msg;
                ma.m_kind := msg_kind.ack_msg;
                ma.m_value := m.m_value;
                ma.m_node := self;
                call net.send(self,leader,ma);
		call service_interface.notify_decision(self,m.m_index,m.m_value);
	}
	else if m.m_kind = msg_kind.ack_msg { #ack_msg to leader.
		call my_debug_value(m.m_value);
		var i : inst_t := 0;
		while i < arr_ackmsg.end(ack_log) {
			var getele : ack_msg_type;
			getele := arr_ackmsg.get(ack_log,i);
			if getele.val = m.m_value {
				getele.node_reply := arr_ack.append(getele.node_reply,m.m_node);
				ack_log := arr_ackmsg.set(ack_log,i,getele);
				call my_debug_node(m.m_node);
			};
			i := i + 1;
			
		}
	}
    }
    implement service_interface.query(i:inst_t) {
	if i >= arr.end(my_log)
	{
	    v.present := false;
	}
	else
	{
	     v.present := true;
	     v.value := arr.get(my_log,i);
	}
    }
    implement timer.timeout {
	var idp : inst_t := 0;
	while idp < proposed_log.end {
		var idval := arr.get(proposed_log,idp);
		var check : bool := false;
		var idm : inst_t := 0;
		while idm < my_log.end { #my_log for self
			if arr.get(my_log,idm) = idval {
				check := true;
			};
			idm := idm + 1;
		};
		if check = false {
			var m : msg;
        		m.m_kind := msg_kind.propose_msg;
        		m.m_value := idval;
        		call net.send(self,leader,m);

		};		
		idp := idp + 1;
	};
	#leader checking if all its proposed values are acknowledged by all other nodes.
	idp := 0;
	while idp < arr_ackmsg.end(ack_log) {
                var getele : ack_msg_type;
                getele := arr_ackmsg.get(ack_log,idp);
		#call my_debug_value(getele.val);
	        var iter := node.iter.create(0);
                while ~iter.is_end
                {
                        var n := iter.val;
			#all other nodes than the leader which is self in this case
			if n ~= self {
				var check : bool := true;
				var idm : inst_t := 0;
				while idm < getele.node_reply.end {
					#call my_debug_node(n); 
					if arr_ack.get(getele.node_reply,idm) = n {
						check := false;
					};
					idm := idm + 1;
				};
				if check = true {
					#we have to determine whether it is a propose message or decision message. 
					#It can be a propose message and that should be sent to the leader if value is not present in leader's my_log
					#It will be a decision message if the value is present in the my_log of leader
					var j : inst_t := 0;
                			var i : inst_t := arr.end(my_log);
                			while j < arr.end(my_log) {
                        			if arr.get(my_log,j) = getele.val {
                                			i := j;
                        			};
                        			j := j + 1;
                			};
					var m : msg;
					if i = arr.end(my_log) {
						m.m_kind := msg_kind.propose_msg;
					}
					#present in my_log of leader
					else {
                        			m.m_kind := msg_kind.decision_msg;
						m.m_index := i;
					};
                        		m.m_value := getele.val;
					if m.m_kind = msg_kind.decision_msg {
						call my_debug_node(self); 
                        			call net.send(self,n,m);
					}
					else {
						call net.send(self,leader,m);
					}
			
				}
			};
                        iter := iter.next;
                };	
                idp := idp + 1;

      };

	
    }

    #proposed is true ans value is contained in my_log then log is also true
    #invariant (service_interface.proposed(self,V) & (arr.value(my_log,I) = V) & (I < arr.end(my_log))) <->  service_interface.log(self,I,V)
    invariant ((arr.value(my_log,I) = V) & (I < arr.end(my_log))) -> service_interface.log(self,I,V)
}
isolate implementation_iso = this with service_interface, inst_t, arr, arr_ack, arr_ackmsg, net, node
# interpret values as strings:
interpret value_t -> strlit

extract impl(n : node) = service_implementation(n), inst_t, arr, arr_ack, arr_ackmsg, node, net(n)

# generate and compile with `ivyc isolate=impl rsm_impl.ivy`
