#lang ivy1.7

# Goal: implement a replicated state-machine (RSM) based on Paxos

include order
include collections

type value_t
instance inst_t: unbounded_sequence

object value_opt_t = {
    type this = struct {
        present : bool,
        value : value_t
    }
}


object service_interface = {
    export action propose(v:value_t) # the environment, i.e. a client application, calls this
    import action notify_decision(i:inst_t, v:value_t) # this is a call out to the environement
    export action query(i:inst_t) returns (v:value_opt_t) # the environment, i.e. a client application, calls this
    specification {
        relation proposed(V:value_t)
        relation log(I:inst_t,V:value_t)
        invariant log(I,V1) & log(I,V2) -> V1 = V2 #an instruction cannot have more than one distinct value
	after init {
		log(I,V) := false;
	}
        before notify_decision {
            ensure proposed(v);
            ensure log(i,V) -> V = v;
            log(i,v) := true;
        }
        after query {
            ensure v.present -> log(i,v.value);
        }
    }
    isolate iso = this
}

object service_implementation = {
# TODO: use an array to implement the log
    instance arr:array(inst_t,value_t)
    individual my_log:arr
    after init
    {
	my_log := arr.empty();
    }
    implement service_interface.propose(v:value_t) {
	var i := my_log.end;
	#my_set := arr.resize(my_set,i.next,0);
	my_log := arr.append(my_log,v);
	call service_interface.notify_decision(i,v);	
    }

    implement service_interface.query(i:inst_t) {
	if i >= my_log.end
	{
	    v.present := false;
	}
	else
	{
	     v.value := my_log.get(i);
	}
    }
    isolate iso = this with service_interface, inst_t
}

# interpret values as strings:
interpret value_t -> strlit

extract impl = service_implementation, inst_t

# generate and compile with `ivyc isolate=impl rsm_impl.ivy`
