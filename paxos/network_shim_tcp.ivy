#lang ivy1.7

#include tcp
include test
#include paxos

object msg_kind = {
    type this = {one_a, one_b, proposal, vote}
}

object msg = {
    type this = struct {
        m_kind : msg_kind,
        m_round : round,
	max_round : round,
        m_value : value,
	m_sender : node
        # TODO: we'll need more fields here
    }
}

instance net : simple_tcp(node,msg)

isolate shim = {

    #You could start by using the shim only to send and receive vote messages, while leaving the rest as is.

    module handler(p_kind) = {
        action handle(dst:node,m:msg)
        object spec = {
            before handle {
		#broadcast is executed
                assert sent(m,dst) & m.m_kind = p_kind
            }
        }
    }

    relation sent(M:msg,N:node)

    instance proposal_handler : handler(msg_kind.proposal)
    instance vote_handler : handler(msg_kind.vote)
    instance onea_handler : handler(msg_kind.one_a)
    instance oneb_handler : handler(msg_kind.one_b)

    action broadcast(src:node,m:msg)

    specification {
        after init {
            sent(M,D) := false;
        }
        before broadcast {
            sent(m,D) := true
        }
    }

    implementation {

        action debug_sending(src:node,dst:node,m:msg)
        action debug_receiving(dst:node,m:msg)

        implement net.recv(dst:node,m:msg) {

            if m.m_kind = msg_kind.proposal {
                call proposal_handler.handle(dst,m)
            }
            else if m.m_kind = msg_kind.vote {
                call vote_handler.handle(dst,m)
            }
	    else if m.m_kind = msg_kind.one_a {
                call onea_handler.handle(dst,m)
            }
	    else if m.m_kind = msg_kind.one_b {
                call oneb_handler.handle(dst,m)
            }
        }

        implement broadcast { # broadcast sends to all nodes, including the sender.
            var iter := node.iter.create(0);
            while ~iter.is_end
            invariant net.sent(M,D) -> sent(M,D)
            {
                var n := iter.val;
                call net.send(src,n,m);
                iter := iter.next;
            }
        }

        private {
            invariant net.sent(M,D) -> sent(M,D)
        }
    }
} with net, node
