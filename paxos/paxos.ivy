#lang ivy1.8

include order
include udp
include array_set

instance node : iterable
type value
type quorum
instance round : unbounded_sequence

relation member(N:node, Q:quorum)
trusted isolate quorum_intersection = {
    axiom forall Q1, Q2. exists N. member(N, Q1) & member(N, Q2)
}

# first, the absract protocol:
isolate abs = {
    relation left_rnd(N:node, R:round) # true for rounds we left, and false for the current round, but otherwise unconstrained
    relation proposal(R:round, V:value) # a leader (implicit) proposes a value for the round
    relation vote(N:node, R:round, V:value) # a node votes on a value for the round
    relation decision(N:node, R:round, V:value)

    after init {
        left_rnd(N,R) := false;
        proposal(R,V) := false;
        vote(N,R,V) := false;
        decision(N,R,V) := false;
    }

    action join_round(n:node, r:round) = {
        require ~left_rnd(n,r);
        left_rnd(n,R) := left_rnd(n,R) | R < r
    }

    action propose(r:round, q:quorum, maxr:round, v:value) = {
        require ~proposal(r,V); # no proposal has been made in round r
        require forall N, R . member(N, q) & R < r -> left_rnd(N,R); # members of q have left all rounds smaller than r

        require ((forall N,R,V. ~(member(N, q) & R < r & vote(N,R,V))) | ( # no member of q has voted before r, or
           (exists N. member(N, q) & maxr < r & vote(N,maxr,v)) & # a member of q has voted for v in round maxr < r, and
           (forall N,R,V. (member(N, q) & R  < r & vote(N,R,V)) -> R <= maxr)) # all votes by members of q cast before round r were cast no later than round maxr
        );
        proposal(r, v) := true
    }

    action cast_vote(n:node, v:value, r:round) = {
        require ~left_rnd(n,r);
        require proposal(r, v);
        vote(n, r, v) := true
    }

    action decide(n:node, r:round, v:value, q:quorum) = {
        require forall N . member(N, q) -> vote(N, r, v);
        decision(n, r, v) := true
    }

    specification {
        # safety property:
        conjecture (
            decision(N1,R1,V1) &
            decision(N2,R2,V2)
        ) -> V1 = V2
    }

    private {
        # proposals are unique per round
        conjecture proposal(R,V1) & proposal(R,V2) -> V1 = V2

        # only vote for proposed values
        conjecture vote(N,R,V) -> proposal(R,V)

        # decisions come from quorums of votes:
        conjecture forall R, V. (exists N. decision(N,R,V)) -> exists Q. forall N. member(N, Q) -> vote(N,R,V)

        # Properties of choosable and proposal
        conjecture forall R1, R2, V1, V2, Q. R1 < R2 & proposal(R2,V2) & V1 ~= V2 ->
            exists N . member(N,Q) & left_rnd(N,R1) & ~vote(N,R1,V1)

    }

} with round, quorum_intersection

# now the more concrete, but still abstract, specification:
isolate protocol = {

    # We now introduce explicit one_b messages that contain the maximum round at which the sender voted and the corresponding value.

    # note that round 0 is never "used" because 1b messages with round 0 are rejected and thus no leader can execute phase 2a for round 0.

    relation one_a(R:round)
    relation one_b(N:node, R:round, MAXR:round, MAXV:value)
    individual current_round(N:node) : round
    relation proposal(R:round, V:value) # 2a
    relation vote(N:node, R:round, V:value) # 2b
    relation decision(N:node, R:round, V:value)

    after init {
        one_a(R) := false;
        one_b(N,R,MAXR,V) := false;
        current_round(N) := 0;
        proposal(R,V) := false;
        vote(N,R,V) := false;
        decision(N,R,V) := false;
    }

    action send_1a(r:round) = {
        one_a(r) := true;
    }

    action send_1b(n:node, r:round, maxr:round, maxv:value) = {
        assume current_round(n) < r;
        assume one_a(r);
        assume ((maxr = 0 & forall R,V. ~(R < r & vote(n,R,V))) |
           (maxr ~= 0 & (maxr < r & vote(n,maxr,maxv)) &
           (forall R,V. (R  < r & vote(n,R,V)) -> R <= maxr))
        );
        current_round(n) := r;
        one_b(n,r,maxr,maxv) := true;
        call abs.join_round(n,r)
    }

    action propose(r:round, q:quorum, maxr:round, v:value) = {
        assume ~proposal(r,V);
        assume forall N. member(N, q) -> exists MAXR,V. one_b(N,r,MAXR,V);

        # find the maximal vote in the quorum
        # here, compared to the protocol isolate, the leader uses the contents of the one_b messages instead of the vote relation
        assume ((forall N. member(N, q) -> exists V . one_b(N,r,0,V)) | (
           (exists N. member(N, q) & maxr < r & one_b(N,r,maxr,v)) &
           (forall N,R,V. (member(N, q) & R  < r & one_b(N,r,R,V)) -> R <= maxr))
        );
        proposal(r, v) := true;
        call abs.propose(r, q, maxr, v)
    }

    action cast_vote(n:node, v:value, r:round) = {
        assume current_round(n) = r;
        assume proposal(r, v);
        vote(n, r, v) := true;
        call abs.cast_vote(n, v, r)
    }

    action decide(n:node, r:round, v:value, q:quorum) = {
        assume forall N . member(N, q) -> vote(N, r, v);
        decision(n, r, v) := true;
        call abs.decide(n, r, v, q)
    }

    export send_1a
    export send_1b
    export propose
    export cast_vote
    export decide

    specification {
        # safety property:
        conjecture [safety] (
          decision(N1,R1,V1) &
          decision(N2,R2,V2)
        ) -> V1 = V2
    }

    private {
        conjecture current_round(N) = R & R <= R2 -> ~abs.left_rnd(N,R2)
        conjecture current_round(N) = R & R2 < R -> abs.left_rnd(N,R2)
        conjecture vote(N,R,V) <-> abs.vote(N,R,V)
        conjecture decision(N,R,V) <-> abs.decision(N,R,V)
        conjecture proposal(R,V) <-> abs.proposal(R,V)
        conjecture one_b(N,R,MAXR,V) & current_round(N) = R2 -> R2 >= R
        conjecture one_b(N,R,MAXR,V) & MAXR ~= 0 -> abs.vote(N,MAXR,V) & (forall R2,V.  (MAXR < R2 & R2 < R -> ~abs.vote(N,R2,V)))
        conjecture one_b(N,R,0,V) & R2 < R -> ~abs.vote(N,R2,V2)
        conjecture one_b(N,R,MAXR,V) -> MAXR < R
    }

} with abs, round, quorum_intersection

isolate interface(n:node) = {
    export action propose(v:value)
    import action decide(v:value)
    specification {
        relation decided(V:value)
        after init {
            decided(V) := false
        }
        before decide {
            require interface.decided(N,V) -> V = v;
            decided(v) := true;
        }
        invariant interface.decided(N1,V1) & interface.decided(N2,V2) -> V1 = V2
    }
}

object msg_kind = {
    type this = {
        1a, # broadcast proposer→acceptors "prepare"
        1b, # unicast acceptor→proposer (reply) "promise"
        2a, # broadcast proposer→acceptors "propose"/"accept"
        2b  # broadcast acceptor→learners "decide"/"vote"
    }
}
type msg = struct {
    m_sender : node,      # used by all messages
    m_kind : msg_kind,    # used by all messages
    m_currnd : round,     # used by all messages
    m_prop_isset : bool,  # used by
    m_prop_round : round, # used by
    m_prop_value : value  # used by
}

instance net : udp_simple(node, msg)
instance node_set : array_set_with_majority(node)

isolate impl = {
    object server(self:node) = {
        # GL: have the node behave as though its in one round for all roles;
        # ignore messages tagged with smaller rounds; for higher rounds,
        # abandon the current and join

        # GL: there's a known bug in paxos-made-simple; rework using the
        # abstract spec above as guidance

        # GL: you have shared predetermined mapping from Round->Node; each node
        # has a predetermined leader

        # GL: distinguish external interface and the send_prepare function;
        # e.g. the one from unanimous_voting; save the proposed value; and
        # instead of learned:bool then call the interface function (or maybe,
        # call it only once using the bool)

        # GL: keep state to ensure that self only proposes once per round

        # GL: use assert instead of require for sanity checks

        # GL: don't even need to keep track of what the votes are for b/c there
        # will only one thing in the round; only one value gets proposed the
        # whole round

        ### constant variables

        # TODO: need some property of leader_of to say that it will be `self`
        # for some round(s)
        function leader_of(R:round):node # TODO: inline C++ def
        # ASSUMPTION: all nodes use the same leader_of function (so that only
        # one value is proposed by one node in each round)

        ### state variables

        function currnd: round          # initialized by init
        function currnd_1b: node_set.t  # initialized by join_round
        function currnd_2b: node_set.t  # initialized by join_round
        function currnd_decided: bool   # initialized by join_round

        # optional: proposal being considered in currnd
        function maxrndprop_isset: bool # initialized by init
        function maxrndprop_round: round # initialialized by interface.propose or handle_1b (as proposer) or handle_2a (as acceptor)
        function maxrndprop_value: value # initialialized by interface.propose or handle_1b (as proposer) or handle_2a (as acceptor)

        ### transition actions

        # internal
        after init {
            maxrndprop_isset := false;
            # join the earliest round that we lead
            currnd := 0;
            while self ~= leader_of(currnd)
            # TODO: loop invariants
            {
                currnd := currnd.next();
            }
            call join_round(currnd);
        }

        # environment interface
        export action timeout = {
            call join_round(currnd.next());
        }

        # internal (called by init or timeout)
        action join_round(r:round) = {
            currnd := r;
            currnd_1b := node_set.emptyset();
            currnd_2b := node_set.emptyset();
            currnd_decided := false;
            if self = leader_of(r) {
                call send_1a();
            }
        }

        # client interface
        implement interface.propose(v:value) {
            if ~maxrndprop_isset {
                maxrndprop_isset := true;
                maxrndprop_value := v;
                maxrndprop_round := currnd;
            }
        }

        # environment interface
        implement net.recv(m:msg) {
            if m.m_currnd < currnd { } # ignore messages from earlier rounds
            else if m.m_kind = msg_kind.1a { call handle_1a(m); }
            else if m.m_kind = msg_kind.1b { call handle_1b(m); }
            else if m.m_kind = msg_kind.2a { call handle_2a(m); }
            else if m.m_kind = msg_kind.2b { call handle_2b(m); }
        }

        # internal
        action new_msg(k:msg_kind) returns (m:msg) = {
            m.m_sender := self;
            m.m_kind := k;
            m.m_currnd := currnd;
        }

        ### PREPARE

        # internal (called by join_round)
        action send_1a = {
            var prep := new_msg(msg_kind.1a);
            var it := node.iter.begin();
            while ~it.is_end
            # TODO loop invariants
            {
                call net.send(self, it.val, prep);
            }
        }
        # internal (called in response to network)
        action handle_1a(prep:msg) = {
            assert prep.m_kind = msg_kind.1a;
            if currnd < prep.m_currnd {
                join_round(prep.m_currnd);
            }
            call send_1b(prep.m_sender);
        }

        ### PROMISE

        # internal (called by handle_1a)
        action send_1b(dst:node) = {
            var prom := new_msg(msg_kind.1b);
            prom.m_prop_isset := maxrndprop_isset;
            prom.m_prop_round := maxrndprop_round;
            prom.m_prop_value := maxrndprop_value;
            call net.send(self, dst, prom);
        }
        # internal (called in response to network)
        action handle_1b(prom:msg) = {
            assert prom.m_kind = msg_kind.1b;
            if currnd = prom.m_currnd {
                currnd_1b := node_set.add(currnd_1b, prom.m_sender);
                if prom.m_prop_isset & (~maxrndprop_isset | maxrndprop_round < prom.m_prop_round) {
                    maxrndprop_isset := true;
                    maxrndprop_round := prom.m_prop_round;
                    maxrndprop_value := prom.m_prop_value;
                }
                if node_set.majority(currnd_1b) {
                    call send_2a(); # FIXME: send only once per round?
                }
            }
            # else: ignore 1b (promises) for the wrong round
        }

        ### PROPOSE

        # internal (called by handle_1b)
        action send_2a = {
            var prop := new_msg(msg_kind.2a);
            prop.m_prop_isset := true;
            prop.m_prop_round := currnd; # NOTE, not the round we learned it from
            prop.m_prop_value := maxrndprop_value;
            var it := node.iter.begin();
            while ~it.is_end
            # TODO loop invariants
            {
                call net.send(self, it.val, prop);
            }
        }
        # internal (called in response to network)
        action handle_2a(prop:msg) = {
            assert prop.m_kind = msg_kind.2a;
            if currnd < prop.m_currnd {
                join_round(prop.m_currnd);
            }
            if ~maxrndprop_isset | (maxrndprop_round < prop.m_prop_round) { # XXX could use prop.currnd in this condition? they're equal
                maxrndprop_isset := true;
                maxrndprop_round := prop.m_prop_round;
                maxrndprop_value := prop.m_prop_value;
                send_2b();
            }
            # else: ignore 2a (proposals) for smaller rounds because 2a is broadcast
        }

        ### VOTE

        # internal (called by handle_2a)
        action send_2b = {
            var vote := new_msg(msg_kind.2b);
            vote.m_prop_isset := maxrndprop_isset; # XXX is true
            vote.m_prop_round := maxrndprop_round; # XXX is currnd
            vote.m_prop_value := maxrndprop_value;
            var it := node.iter.begin();
            while ~it.is_end
            # TODO loop invariants
            {
                call net.send(self, it.val, vote);
            }
        }
        # internal (called in response to network)
        action handle_2b(decision:msg) = {
            assert decision.m_kind = msg_kind.2b;
#           # (re)set decision fields if they've never been set or if it's a new round
#           if ~decision_isset | decision_round < vote.m_round {
#               decision_isset := true;
#               decision_round := vote.m_round;
#               decision_value := vote.m_value;
#               decided := node_set.emptyset();
#               learned := false;
#           }
#           # track acceptances to learn the value
#           if decision_round = vote.m_round {
#               # (?) require decision_value = vote.m_value;
#               decided := node_set.add(decided, vote.m_sender);
#               if node_set.majority(decided) {
#                   # TODO: call the interface function
#                   learned := true;
#               }
#           }
        }

    }
}
