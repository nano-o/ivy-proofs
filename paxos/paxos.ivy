#lang ivy1.8

include order
include udp
include array_set

instance node : iterable
type value
type quorum
instance round : unbounded_sequence

relation member(N:node, Q:quorum)
trusted isolate quorum_intersection = {
    axiom forall Q1, Q2. exists N. member(N, Q1) & member(N, Q2)
}

# first, the absract protocol:
isolate abs = {
    relation left_rnd(N:node, R:round) # true for rounds we left, and false for the current round, but otherwise unconstrained
    relation proposal(R:round, V:value) # a leader (implicit) proposes a value for the round
    relation vote(N:node, R:round, V:value) # a node votes on a value for the round
    relation decision(N:node, R:round, V:value)

    after init {
        left_rnd(N,R) := false;
        proposal(R,V) := false;
        vote(N,R,V) := false;
        decision(N,R,V) := false;
    }

    action join_round(n:node, r:round) = {
        require ~left_rnd(n,r);
        left_rnd(n,R) := left_rnd(n,R) | R < r
    }

    action propose(r:round, q:quorum, maxr:round, v:value) = {
        require ~proposal(r,V); # no proposal has been made in round r
        require forall N, R . member(N, q) & R < r -> left_rnd(N,R); # members of q have left all rounds smaller than r

        require ((forall N,R,V. ~(member(N, q) & R < r & vote(N,R,V))) | ( # no member of q has voted before r, or
           (exists N. member(N, q) & maxr < r & vote(N,maxr,v)) & # a member of q has voted for v in round maxr < r, and
           (forall N,R,V. (member(N, q) & R  < r & vote(N,R,V)) -> R <= maxr)) # all votes by members of q cast before round r were cast no later than round maxr
        );
        proposal(r, v) := true
    }

    action cast_vote(n:node, v:value, r:round) = {
        require ~left_rnd(n,r);
        require proposal(r, v);
        vote(n, r, v) := true
    }

    action decide(n:node, r:round, v:value, q:quorum) = {
        require forall N . member(N, q) -> vote(N, r, v);
        decision(n, r, v) := true
    }

    specification {
        # safety property:
        conjecture (
            decision(N1,R1,V1) &
            decision(N2,R2,V2)
        ) -> V1 = V2
    }

    private {
        # proposals are unique per round
        conjecture proposal(R,V1) & proposal(R,V2) -> V1 = V2

        # only vote for proposed values
        conjecture vote(N,R,V) -> proposal(R,V)

        # decisions come from quorums of votes:
        conjecture forall R, V. (exists N. decision(N,R,V)) -> exists Q. forall N. member(N, Q) -> vote(N,R,V)

        # Properties of choosable and proposal
        conjecture forall R1, R2, V1, V2, Q. R1 < R2 & proposal(R2,V2) & V1 ~= V2 ->
            exists N . member(N,Q) & left_rnd(N,R1) & ~vote(N,R1,V1)

    }

} with round, quorum_intersection

# now the more concrete, but still abstract, specification:
isolate protocol = {

    # We now introduce explicit one_b messages that contain the maximum round at which the sender voted and the corresponding value.

    # note that round 0 is never "used" because 1b messages with round 0 are rejected and thus no leader can execute phase 2a for round 0.

    relation one_a(R:round)
    relation one_b(N:node, R:round, MAXR:round, MAXV:value)
    individual current_round(N:node) : round
    relation proposal(R:round, V:value) # 2a
    relation vote(N:node, R:round, V:value) # 2b
    relation decision(N:node, R:round, V:value)

    after init {
        one_a(R) := false;
        one_b(N,R,MAXR,V) := false;
        current_round(N) := 0;
        proposal(R,V) := false;
        vote(N,R,V) := false;
        decision(N,R,V) := false;
    }

    action send_1a(r:round) = {
        one_a(r) := true;
    }

    action send_1b(n:node, r:round, maxr:round, maxv:value) = {
        assume current_round(n) < r;
        assume one_a(r);
        assume ((maxr = 0 & forall R,V. ~(R < r & vote(n,R,V))) |
           (maxr ~= 0 & (maxr < r & vote(n,maxr,maxv)) &
           (forall R,V. (R  < r & vote(n,R,V)) -> R <= maxr))
        );
        current_round(n) := r;
        one_b(n,r,maxr,maxv) := true;
        call abs.join_round(n,r)
    }

    action propose(r:round, q:quorum, maxr:round, v:value) = {
        assume ~proposal(r,V);
        assume forall N. member(N, q) -> exists MAXR,V. one_b(N,r,MAXR,V);

        # find the maximal vote in the quorum
        # here, compared to the protocol isolate, the leader uses the contents of the one_b messages instead of the vote relation
        assume ((forall N. member(N, q) -> exists V . one_b(N,r,0,V)) | (
           (exists N. member(N, q) & maxr < r & one_b(N,r,maxr,v)) &
           (forall N,R,V. (member(N, q) & R  < r & one_b(N,r,R,V)) -> R <= maxr))
        );
        proposal(r, v) := true;
        call abs.propose(r, q, maxr, v)
    }

    action cast_vote(n:node, v:value, r:round) = {
        assume current_round(n) = r;
        assume proposal(r, v);
        vote(n, r, v) := true;
        call abs.cast_vote(n, v, r)
    }

    action decide(n:node, r:round, v:value, q:quorum) = {
        assume forall N . member(N, q) -> vote(N, r, v);
        decision(n, r, v) := true;
        call abs.decide(n, r, v, q)
    }

    export send_1a
    export send_1b
    export propose
    export cast_vote
    export decide

    specification {
        # safety property:
        conjecture [safety] (
          decision(N1,R1,V1) &
          decision(N2,R2,V2)
        ) -> V1 = V2
    }

    private {
        conjecture current_round(N) = R & R <= R2 -> ~abs.left_rnd(N,R2)
        conjecture current_round(N) = R & R2 < R -> abs.left_rnd(N,R2)
        conjecture vote(N,R,V) <-> abs.vote(N,R,V)
        conjecture decision(N,R,V) <-> abs.decision(N,R,V)
        conjecture proposal(R,V) <-> abs.proposal(R,V)
        conjecture one_b(N,R,MAXR,V) & current_round(N) = R2 -> R2 >= R
        conjecture one_b(N,R,MAXR,V) & MAXR ~= 0 -> abs.vote(N,MAXR,V) & (forall R2,V.  (MAXR < R2 & R2 < R -> ~abs.vote(N,R2,V)))
        conjecture one_b(N,R,0,V) & R2 < R -> ~abs.vote(N,R2,V2)
        conjecture one_b(N,R,MAXR,V) -> MAXR < R
    }

} with abs, round, quorum_intersection

object msg_kind = {
    type this = {
        prepare, # 1a broadcast proposer→acceptors
        promise, # 1b unicast acceptor→proposer (reply)
        propose, # 2a broadcast proposer→acceptors
        decide   # 2b broadcast acceptor→learners
    }
}
type msg = struct {
    m_sender : node,    # used by all messages
    m_kind : msg_kind,  # used by all messages
    m_round : round,    # used by prepare, promise, propose, decide
    m_value : value,    # used by          promise, propose, decide
    m_accepted : bool,  # used by          promise                  (to indicate whether m_round and m_value are set)
    m_promised : round  # used by          promise                  (to indicate which prepare message we're responding to)
}

instance net : udp_simple(node, msg)
instance node_set : array_set_with_majority(node)

isolate impl = {
    object server(self:node) = {

        # as proposer

        function proposing_round: round # round for which we have sent prepare messages
        function proposing_value: value # value we will propose if we receive enough promises
        function promised: node_set.t # acceptors who've promised the round we're proposing

        function promised_isset: bool # whether the next field is valid
        function promised_round: round # max round value seen among promises

        # as acceptor

        function prepared_isset: bool # whether the next field is valid
        function prepared_round: round # highest round we've promised not to accept less than

        function accepted_isset: bool # whether the next two fields are valid
        function accepted_round: round
        function accepted_value: value

        # as decider

        # optional -- highest proposal we've learned was accepted
        function decision_isset: bool # whether the next three fields are valid
        function decision_round: round
        function decision_value: value

        function decided: node_set.t # acceptors agree with the `decision` proposal
        function learned: bool # whether the `decision` proposal has a majority

        after init {
            promised := node_set.emptyset();
            promised_isset := false;
            prepared_isset := false;
            accepted_isset := false;
            decision_isset := false;
        }

        implement net.recv(req:msg) {
            if req.m_kind = msg_kind.prepare {
                call acceptor_handle_prepare(req);
            } else if req.m_kind = msg_kind.promise {
                call proposer_handle_promise(req);
            } else if req.m_kind = msg_kind.propose {
                call acceptor_handle_propose(req);
            } else if req.m_kind = msg_kind.decide {
                call learner_handle_decide(req);
            }
        }

        export action proposer_send_prepare(r:round, v:value) = {
            proposing_round := r;
            proposing_value := v;
            var prep:msg;
            prep.m_sender := self;
            prep.m_kind := msg_kind.prepare;
            prep.m_round := proposing_round;
            var it := node.iter.begin();
            while ~it.is_end
            # TODO loop invariants
            {
                call net.send(self, it.val, prep);
            }
        }

        # internal (called in response to network)
        action acceptor_handle_prepare(prep:msg) = {
            require prep.m_kind = msg_kind.prepare;
            if ~prepared_isset | prepared_round < prep.m_round {
                prepared_isset := true;
                prepared_round := prep.m_round;
                call acceptor_send_promise(prep.m_sender);
            }
        }

        # internal (called in response to a prepare)
        action acceptor_send_promise(dst:node) = {
            var prom:msg;
            prom.m_sender := self;
            prom.m_kind := msg_kind.promise;
            prom.m_promised := prepared_round;
            prom.m_accepted := accepted_isset;
            prom.m_round := accepted_round;
            prom.m_value := accepted_value;
            call net.send(self, dst, prom);
        }

        # internal (called in response to network)
        action proposer_handle_promise(prom:msg) = {
            require prom.m_kind = msg_kind.promise;
            # is this a response to our (most recent) prepare?
            if proposing_round = prom.m_promised {
                # remember that the sender promised
                promised := node_set.add(promised, prom.m_sender);
                # track the greatest round & value already accepted by others
                if prom.m_accepted & (~promised_isset | promised_round < prom.m_round) {
                    promised_isset := true;
                    promised_round := prom.m_round;
                    proposing_value := prom.m_value;
                    # FIXME: what about the case where we receive two promises,
                    # with the same round but distinct values? TODO: double
                    # check the paper
                }
                if node_set.majority(promised) {
                    call proposer_send_propose();
                }
            }
            # else: ignore promises for the wrong round
        }

        # internal (to call this, use proposer_send_prepare)
        action proposer_send_propose = {
            var prop:msg;
            prop.m_sender := self;
            prop.m_kind := msg_kind.propose;
            prop.m_round := proposing_round;
            prop.m_value := proposing_value;
            var it := node.iter.begin();
            while ~it.is_end
            # TODO loop invariants
            {
                call net.send(self, it.val, prop);
            }
        }

        # internal (called in response to network)
        action acceptor_handle_propose(prop:msg) = {
            require prop.m_kind = msg_kind.propose;
            if ~prepared_isset | ~(prepared_round > prop.m_round) {
                accepted_isset := true;
                accepted_round := prop.m_round;
                accepted_value := prop.m_value;
                acceptor_send_decide(prop.m_round, prop.m_value);
                # FIXME: what about the case where we receive two proposals,
                # with the same round but distinct values? TODO: double check
                # the paper
            }
        }

        # internal (called in response to a propose)
        action acceptor_send_decide(r:round, v:value) = {
            var dec:msg;
            dec.m_sender := self;
            dec.m_kind := msg_kind.decide;
            dec.m_round := r;
            dec.m_value := v;
            var it := node.iter.begin();
            while ~it.is_end
            # TODO loop invariants
            {
                call net.send(self, it.val, dec);
            }
        }

        # internal (called in response to network)
        action learner_handle_decide(dec:msg) = { # FIXME: this fn is all guesswork
            require dec.m_kind = msg_kind.decide;
            # (re)set decision fields if they've never been set or if it's a new round
            if ~decision_isset | decision_round < dec.m_round {
                decision_isset := true;
                decision_round := dec.m_round;
                decision_value := dec.m_value;
                # FIXME: what about the case where we receive two decides, with
                # the same round but distinct values?
                decided := node_set.emptyset();
                learned := false;
            }
            # track acceptances to learn the value
            if decision_round = dec.m_round {
                # (?) require decision_value = dec.m_value;
                decided := node_set.add(decided, dec.m_sender);
                if node_set.majority(decided) {
                    learned := true;
                }
            }
        }

    }
}
