#lang ivy1.7

include order

type node
type value
instance round : unbounded_sequence
type nset

relation well_behaved(N:node)
relation intertwined(N:node)
relation intact(N:node)

# intact nodes are intertwined
axiom intact(N) -> intertwined(N)
# intertwined nodes are well-behaved
axiom intertwined(N) -> well_behaved(N)

relation member(N:node, Q:nset)
relation is_quorum(Q:nset)

# quorum intersection for intact nodes:
axiom (exists N1 . intact(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intact(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)

# quorum intersection for intertwined nodes:
axiom (exists N1 . intertwined(N1) & is_quorum(Q1) & member(N1,Q1)) & (exists N2 . intertwined(N2) & is_quorum(Q2) & member(N2,Q2)) -> exists N3 . well_behaved(N3) & member(N3,Q1) & member(N3,Q2)

relation blocks_slices(S:nset, N:node)
# if set R blocks an intact node then R contains an intact node
# QAG edge nset -> node
axiom (exists N . intact(N) & blocks_slices(S,N)) -> exists N2 . member(N2,S) & intact(N2)

# the set of all intact nodes is a quorum
#axiom exists Q . (forall N . member(N,Q) <-> intact(N)) & is_quorum(Q)

relation left_round(N:node, R:round)
relation prepared(N:node, R:round, V:value)
relation precommitted(N:node, R:round, V:value)
relation committed(N:node, R:round, V:value)
relation decided(N:node, R:round, V:value)
relation locked(N:node, R:round, V:value)
#relation all_safe(N:node, R:round) # node N believes all values are safe below R

after init {
    left_round(N,R) := false;
    prepared(N,R,V) := false;
    precommitted(N,R,V) := false;
    committed(N,R,V) := false;
    decided(N,R,V) := false;
    locked(N,R,V) := false;
    #all_safe(N,R) := false;
}

export action join_round(n:node, r:round) = {
    assume ~left_round(n,r);
    left_round(n,R) := R < r;
}

export action prepare(n:node, r:round, v:value) = {
    assume ~prepared(n,r,V); # prepare only once (NOTE: could be removed; does not impact safety)
    assume ~left_round(N,r);
    assume locked(n,R,V) -> V = v;
    prepared(n, r, v) := true;
    left_round(n, R) := R < r; # cannot commit in lower rounds anymore
}

#action update_all_safe(n:node, r1:round, v1:value, r2:round, v2:value) = {
    #assume r1 < r2 & v1 ~= v2 & (precommitted(n,r1,v1) | committed(n,r1,v1)) & (precommitted(n,r2,v2) | committed(n,r2,v2));
    #all_safe(n, R) := all_safe(n, R) | R <= r1;
#}

export action precommit(n:node, r:round, v:value, q:nset) = {
    assume is_quorum(q) & member(n,q);
    assume member(N,q) -> prepared(N,r,v);
    precommitted(n, r, v) := true;
}

export action relay_precommit(n:node, r:round, v:value, b:nset) = {
    assume blocks_slices(b,n);
    assume member(N,b) -> exists R . r <= R & precommitted(N,R,v);
    precommitted(n, r, v) := true;
}

export action unlock(n:node, r:round, v:value, b:nset) = {
    assume blocks_slices(b,n);
    assume locked(n, r, v);
    assume member(N,b) -> exists R,V . r < R & V ~= v & precommitted(N,R,V);
    locked(n, r, v) := false;
}

export action commit(n:node, r:round, v:value, q:nset) = {
    assume ~left_round(n,r);
    assume ~committed(n,r,V); # don't commit twice in the same round
    assume is_quorum(q) & member(n,q);
    assume member(N,q) -> precommitted(N,r,v);
    committed(n, r, v) := true;
    left_round(n, R) := R < r; # cannot prepare in lower rounds anymore
    locked(n, R, V) := R = r & V = v; # release any existing lock and take a new lock
}

export action decide(n:node, r:round, v:value, q:nset) = {
    assume is_quorum(q) & member(n,q);
    assume member(N, q) -> committed(N, r, v);
    decided(n, r, v) := true;
}

# There is no Byzantine action because the invariants below do not say anything about Byzantine nodes. Therefore their state can evolve arbitrarily without breaking the invariants.

# the agreement property:
#########################
invariant [safety] ( intact(N1) & intact(N2) & decided(N1,R1,V1) & decided(N2,R2,V2)) -> V1 = V2

# notion of choosable and safe at:
##################################
relation quorum_of_intact(Q:nset)
definition quorum_of_intact(Q) = (is_quorum(Q) & exists N . intact(N) & member(N,Q))
relation choosable(R:round, V:value)
definition choosable(R,V) = exists Q . quorum_of_intact(Q) & forall N . well_behaved(N) & member(N,Q) -> ~left_round(N,R) | committed(N,R,V)
relation safe_at(R:round, V:value)
definition safe_at(R2,V2) = forall R1,V1 . R1 < R2 & V1 ~= V2 -> ~choosable(R1,V1)

# the three invariants below are top-level:
###########################################

invariant [main] intact(N) & (decided(N,R,V) | committed(N,R,V) | precommitted(N,R,V)) -> safe_at(R,V)

invariant [decision_is_quorum_commit] (exists N1 . intact(N1) & decided(N1,R,V)) -> exists Q. quorum_of_intact(Q) & forall N2. well_behaved(N2) & member(N2, Q) -> committed(N2,R,V)

invariant [commit_unique_per_round] well_behaved(N) & committed(N,R,V) & committed(N,R,V2) -> V = V2

# the other crucial invariant:
##############################

# a well-behaved node keeps holding a lock on a committed value and does not prepare something else as long as the value is choosable:
invariant [locks] intact(N) & committed(N,R,V) & choosable(R,V) -> (exists R2 . R <= R2 & locked(N,R2,V)) & (R < R3 & prepared(N,R3,V3) -> V = V3)

# now, supporting invariants:
#############################

# if a node left round R2>R1, then it also left R1
invariant well_behaved(N) & left_round(N,R2) & R1 < R2 -> left_round(N,R1)

# nodes stop preparing or committing in lower rounds when doing so in a higher round:
invariant well_behaved(N) & prepared(N,R2,V2) & R1 < R2 -> left_round(N,R1)
invariant well_behaved(N) & committed(N,R2,V2) & R1 < R2 -> left_round(N,R1)
