#lang ivy1.8

include order
include udp
include collections

type value
instance node : iterable

isolate interface(n:node) = {
    export action propose(v:value)
    import action decide(v:value)
    specification {
        relation decided(V:value)
        after init {
            decided(V) := false
        }
        after decide {
            decided(v) := true;
            ensure interface.decided(N,V) -> V = v;
        }
        invariant interface.decided(N1,V1) & interface.decided(N2,V2) -> V1 = V2
    }
}

isolate abstract_protocol = {
    relation vote(N:node, V:value)
    relation decided(N:node, V:value)
    after init {
        vote(N,V) := false;
        decided(N,V) := false;
    }
    action do_vote(n:node,v:value) = {
        vote(n,v) := true;
    }
    action decide(n:node, v:value) = {
        require vote(N,v);
        decided(n,v) := true
    }
    invariant decided(N1,V1) & decided(N2,V2) -> V1 = V2
}

isolate system = {
    interpret value -> bv[1]
    type msg = struct {
        id : node,
        val : value
    }

    instance net : udp_simple(node, msg)

    instance vote_array : keyval(index, node, value)

    # NOTE tried a parameterized object `protocol(self:node)` but then `implement net.recv(v:value)` does not work (ivy complains about a wrong number of parameters).
    isolate protocol = {
        function votes(N:node): vote_array
        implement interface.propose(self:node, v:value) {
            var dst := node.iter.begin();
            while ~dst.is_end {
                var m:msg;
                m.id := self;
                m.val := v;
                call net.send(self, dst.val, m);
                dst := dst.next();
            }
        }
        implement net.recv(self:node, m:msg) {
            votes(self) := votes(self).append_pair(m.id, m.val);

            # check whether all have voted:
            # TODO

            # check whether we have unanimous votes:
            var i:index := 0;
            var unanimous:bool := true;
            var v := votes(self).get_value(i);
            i := i.next();
            while (i < votes(self).end() & unanimous) {
                var curr := votes(self).get_value(i);
                if curr ~= v {
                    unanimous := false;
                };
                i := i.next();
            };
        }
    } with interface, net, node, vote_array
}

extract impl(n:node) = system.protocol(n), system.net(n), node, system.vote_array
