#lang ivy1.7

# This file contains an implementation of the Multi-Paxos protocol (without log truncation).
# The specification of the client interface appears in the specification block of the server object.

include timeout # from standard library

include multi_paxos_protocol
include network_shim_tcp

# Every round has a leader. We represent this with the inverse
# functional relation `leader_of`. If we use the spec of this
# isolate, we get just the injectivity property, whereas the
# impl also gives us totality.
relation leader_of(N:node, E:round_t)
isolate round_leader = {
    action get_leader(r:round_t) returns (n:node) # TODO: needed?
    action get_next_round(r:round_t, n:node) returns (s:round_t)
    specification {
        property [injectivity] leader_of(Y,X) & leader_of(Z,X) -> Y = Z
        after get_leader {
            ensure leader_of(n,r)
        }
        after get_next_round {
            ensure r < s & leader_of(n,s)
        }
    }
    implementation {
        function leader_fun(R:round_t) : node
        definition leader_of(N,R) = (N = leader_fun(R))
        implement get_leader(r:round_t) {
            n := leader_fun(r)
        }
        implement get_next_round {
            var iter := r.next;
            while ~leader_of(n,iter)
            invariant r < iter
            {
                iter := iter.next
            };
            s := iter;
        }
    }
} with round_t

# no_ops to fill holes in the log
individual no_op : value_t

# Multi-Paxos implementation
isolate system = {
    
    type ballot_status = struct {
        active : bool,
        voters : nset,
        proposal : value_t,
        decided : bool
    }
    instance ballot_status_array : array(inst_t, ballot_status)
    individual init_status : ballot_status
    # default status for initialization
    isolate status_initialization = {
        invariant ~init_status.decided & ~nset.member(N,init_status.voters) & ~init_status.active
        after init {
            init_status.active := false;
            init_status.decided := false;
            init_status.voters := nset.emptyset();
        }
    } with nset

    type decision_struct = struct {
        decision: value_t,
        done: bool
    }
    
    instance log : array(inst_t, decision_struct)
    
    individual no_decision : decision_struct
    isolate no_decision_initialization = {
        after init {
            no_decision.done := false
        }
        invariant ~no_decision.done
    }   

    object server(self:node) = {

        # API for client code:
        # returns false and does nothing if called on a node where leader_of(self,current_round)=false or current_round is not yet active.
        action propose(v:value_t) returns (r:bool)

        # called by the client to query the log
        export action query(i:inst_t) returns (d:decision_struct)

        # called by server to report a decision
        export action decide(i:inst_t,v:value_t)

        # the service specification:
        # do not change; the key-value store shim depends on this interface
        specification {
            
            relation decided(S:inst_t,V:value_t)

            invariant decided(I,V) -> abs_paxos.decision(I,V)

            object spec_init = { #TODO: why an object for this?
                after init {
                    decided(I,V) := false;
                }
            }

            # agreement:
            around decide {
                require abs_paxos.decision(i,v);
                ...
                decided(i,v) := true;
                ensure server.decided(N,i,V) -> V = v;
            }

            after query {
                ensure d.done -> decided(i,d.decision)
            }
        }
    }

    # Interface between model and controller. 

    object control_intf(self:node) = {

        # Calls from controller to model

        # propose an instance that is currently waiting
        # action propose_waiting(i : inst_t) 

        # propose an instance during recovery
        action propose_highest_or_noop(i : inst_t)

        # retransmit two_a message for a pending instance
        action retransmit_two_a(i : inst_t)
        
        # ask for a missing (undecided) instance
        # action ask_missing(i:inst_t)

        # leader sends a keep_alive message
        action send_keep_alive

        # start a new round
        action timed_out_on_leader

        action activate_round

        # Calls from model to controller

        action notify_decision(i:inst_t) # TODO: unused

        action notify_two_a(i:inst_t)

        action notify_changed_round(r:round_t) # notify leader-election object

        action notify_keep_alive

        action notify_leadership_acquired(begin:inst_t, end:inst_t)

        action notify_first_undecided(i:inst_t) # TODO: could be merged with notify_decision

        # Specification variables to maintain mutual invariants between model and controller:
        individual current_round:round_t
        individual first_undecided:inst_t
        individual repropose_bound:inst_t
        relation leader_ready
        relation leadership_acquired
        individual next_inst:inst_t

        specification {

            # TODO: why use leader_of here? Those invariants are maintained by the model
            invariant leadership_acquired -> leader_of(self, current_round)
            invariant leader_ready -> leader_of(self, current_round) & leadership_acquired

            after init {
                current_round := 0;
                first_undecided := 0;
                leader_ready := leader_of(self,0);
                leadership_acquired := leader_of(self,0);
                next_inst := 0;
            }
            before propose_highest_or_noop(i:inst_t) {
                # TODO: reformat
                assert leader_of(self, current_round);
                assert leadership_acquired;
                assert ~leader_ready;
                assert first_undecided <= i;
                assert i < repropose_bound;
                assert i = next_inst;
                next_inst := next_inst.next
            }
            before notify_two_a {
                # TODO: needed?
                # assert first_undecided <= i
            }
            before send_keep_alive {
                assert leader_of(self, current_round)
            } 
            before notify_changed_round {
                current_round := r;
                leader_ready := false;
                leadership_acquired := false;
            }
            before retransmit_two_a {
                assert leader_of(self, current_round)
            }
            before notify_leadership_acquired {
                require leader_of(self, current_round) & ~leadership_acquired;
                require begin <= end;
                next_inst := begin;
                first_undecided := begin;
                leadership_acquired := true;
                repropose_bound := end;
            }
            before activate_round {
                assert leader_of(self, current_round);
                assert leadership_acquired;
                assert ~leader_ready;
                assert next_inst = repropose_bound;
                leader_ready := true;
            }
            before notify_first_undecided {
                first_undecided := i;
            }
        }
    }

    object model(self:node) = {
        
        individual current_round : round_t
        individual next_inst : inst_t # next free consensus instance 
        individual inst_status : ballot_status_array # votes received in the current round, per instance. TODO: make a window, otherwise a lot of space may be waste if a new leader takes over after many instances
        individual my_log : log # the decision log
        individual first_undecided : inst_t # the first "hole" in the log
        # data structures used upon leadership change:
        relation leader_ready # true when successfully acquired leadership # TODO: bad name
        individual my_votes : votemap # max votes by self.
        individual joined: nset # the set of nodes that joined the current round so far
        individual joined_votes: win # window data-structure to hold replica votes upon leader change
        relation leadership_acquired

        function is_decided(J:inst_t):bool
        definition is_decided(J:inst_t) = (J < my_log.end & my_log.value(J).done)

        after init {
            current_round := 0;
            next_inst := 0;
            my_votes := votemap.empty;
            joined := nset.emptyset();
            joined_votes := win.empty(0);
            leadership_acquired := leader_of(self,0); # when a quorum joins the leader's round
            leader_ready := leader_of(self,0); # after leadership_acquired, when the leader is ready to accept new proposals
            inst_status := ballot_status_array.empty;
            my_log := log.empty;
            first_undecided := 0;
        }
        

        ################################################################################
        # Here, we implement the server side of the client API

        implement server.query(i:inst_t) {
            if is_decided(i) {
                d.decision := my_log.value(i).decision;
                d.done := true;
            }
            else d.done := false;
        }

        implement server.propose(v:value_t) returns (ret:bool) {
            if leader_of(self, current_round) & leader_ready {
                call abs_paxos.propose(next_inst, current_round, v, joined, 0); # 0 is a dummy value with no meaning in this case
                call do_propose(next_inst, v);
                ret := true;
            }
            else {
                ret := false;
            }
        }

        ################################################################################
        # Here, we implement the handler side of the network interface

        implement shim.one_a_handler.handle(m:msg) {
            if current_round < m.m_round {
                call join_round(m.m_round);
                var m2:msg;
                m2.m_kind := msg_kind.one_b;
                m2.m_round := m.m_round;
                m2.m_node := self;
                var i := m.m_inst; # lowest instance requested by the leader
                m2.m_inst := i;

                if (i < my_votes.end) {
                    m2.m_votes := win.make_from_array(i, my_votes);
                }
                else {
                    m2.m_votes := win.empty(i);
                };
                var leader:node := m.m_node;
                call shim.unicast(self,leader,m2);
            };
        }

        import action debug_acquired(r:round_t)
        implement shim.one_b_handler.handle(m:msg) {
            if current_round = m.m_round & ~leadership_acquired {
                joined := joined.add(m.m_node);
                joined_votes := joined_votes.zip_max(m.m_votes);

                if joined.majority {
                    call debug_acquired(current_round);
                    leadership_acquired := true;
                    next_inst := first_undecided;
                    # notify the controller
                    call control_intf.notify_leadership_acquired(self, first_undecided, joined_votes.getEnd());
                }
            }
        }
        
        # receiving a proposal:
        implement shim.two_a_handler.handle(m:msg) {
            if (current_round = m.m_round) {

                if ~is_decided(m.m_inst) {
                    call vote(m.m_node, m.m_inst, m.m_value);
                }
                else if (m.m_node ~= self) {
                    # TODO: send decide message?
                    # var m2:msg := build_decide_msg(m.m_inst);
                    # call shim.unicast(self, m.m_node, m2);
                };

                if (first_undecided < m.m_inst) {
                    #call ask_for_retransmission(m.m_inst);
                }
            }
        }

        implement shim.decide_handler.handle(m:msg) {
            if (~is_decided(m.m_inst) & ~(leader_of(self, current_round))) {
                if (inst_status.size <= m.m_inst.next) {
                    inst_status := inst_status.resize(m.m_inst.next,init_status);
                };
                call do_decide(m.m_inst, m.m_value);
            }
        }
        
        import action debug_two_b_handler(a:bool)
        # receiving a vote:
        
        implement shim.two_b_handler.handle(m:msg) {
            # checking that the if condition is not a tautology:
            # assert leader_of(self, current_round) & leader_ready & m.m_round = current_round;
            if (leader_of(self, current_round) & leader_ready & m.m_round = current_round) {
                if inst_status.end <= m.m_inst { # TODO: should not happen! Get rid of it with an invariant.
                    inst_status := inst_status.resize(m.m_inst.next, init_status)
                };
                #call debug_two_b_handler(false);

                var status := inst_status.get(m.m_inst);
                if (~status.decided & status.active) {
                    status.voters := status.voters.add(m.m_node);
                    inst_status := inst_status.set(m.m_inst,status);
                    assert I < inst_status.end & nset.member(N,inst_status.value(I).voters) -> abs_paxos.vote(N,I,current_round,inst_status.value(I).proposal);
                    if status.voters.majority {
                        assert I < inst_status.end & nset.member(N,inst_status.value(I).voters) -> abs_paxos.vote(N,I,current_round,inst_status.value(I).proposal);
                        #call debug_two_b_handler(true);
                        call abs_paxos.decide(m.m_inst, current_round, status.proposal, status.voters); # ghost
                        call do_decide(m.m_inst, m.m_value); # TODO: why does this randomly fails?
                        var m2:msg := build_decide_msg(m.m_inst);
                        call shim.bcast(self,m2);
                    };
                    inst_status := inst_status.set(m.m_inst,status)
                }
            }
        }

        implement shim.keep_alive_handler.handle(m:msg) {
            call control_intf.notify_keep_alive(self);
        }

        implement shim.notify_round(r:round_t) {
            if (current_round < r & ~leader_of(self, r)) { # second condition should not happen. TODO: eliminate with invariant
                call join_round(r);
            }
        }

        ################################################################################
        # Here we implement the model side of the controller/model interface

        # called when timing out on the current leader:
        implement control_intf.timed_out_on_leader {
            call join_round(round_leader.get_next_round(current_round, self));
            
            # self joins the current round:
            joined := nset.emptyset();
            joined := joined.add(self);
            joined_votes := win.make_from_array(first_undecided, my_votes);

            # broacast one_a
            var m:msg;
            m.m_kind := msg_kind.one_a;
            m.m_round := current_round;
            m.m_node := self;
            m.m_inst := first_undecided; # here we request only instances after the first undecided instance.
            call shim.bcast(self,m);
        }

        implement control_intf.retransmit_two_a(i:inst_t) {
            if i < inst_status.end & inst_status.value(i).active & ~inst_status.value(i).decided { # TODO: this should be implied by an invariant
                var m:msg;
                m.m_kind := msg_kind.two_a;
                m.m_node := self;
                m.m_round := current_round;
                m.m_inst := i;
                m.m_value := inst_status.value(i).proposal;
                call shim.bcast(self, m);
                call control_intf(self).notify_two_a(i);
            }
        }

        implement control_intf.send_keep_alive {
            var m : msg;
            m.m_kind := msg_kind.keep_alive;
            m.m_round := current_round;
            m.m_node := self;
            call shim.bcast(self,m);
        }

        implement control_intf.propose_highest_or_noop(i:inst_t) {
            var highest := joined_votes.read(i);
            if highest.present {
                call do_propose(i, highest.val);
                call abs_paxos.propose(i, current_round, highest.val, joined, highest.rnd);
            }
            else {
                call do_propose(i, no_op);
                call abs_paxos.propose(i, current_round, no_op, joined, 0); # 0 is a dummy value with no meaning in this case
            };
        }

        action debug_leader_ready(r:round_t)
        import debug_leader_ready
        implement control_intf.activate_round {
            call debug_leader_ready(current_round);
            leader_ready := true;
            #next_inst := joined_votes.getEnd();
        }

        ################################################################################
        # Here we have internal actions

        action do_propose(i:inst_t, v:value_t) = {
            var m:msg := build_proposal(i,v);
            call shim.bcast(self,m);
            call control_intf(self).notify_two_a(i);

            if (inst_status.end <= i) {
                inst_status := inst_status.resize(i.next, init_status)
            };
            var status:ballot_status := inst_status.get(i);
            status.active := true;
            status.proposal := v;
            inst_status := inst_status.set(i, status);

            next_inst := i.next;
        }

        action do_decide(i:inst_t, v:value_t) = { # TODO: move to internal actions section
            if (my_log.size <= i.next) {
                my_log := my_log.resize(i.next,no_decision);
            };
            var d: decision_struct;
            d.done := true;
            d.decision := v;
            my_log := my_log.set(i,d);
            
            call update_first_undecided(i);
            
            var status := inst_status.get(i);
            status.decided := true;
            inst_status := inst_status.set(i,status);
            
            call server(self).decide(i,v); 
        }

        action build_proposal(j:inst_t, v:value_t) returns (m:msg) = {
            m.m_kind := msg_kind.two_a;
            m.m_round := current_round;
            m.m_node := self;
            m.m_inst := j;
            m.m_value := v;
        }
        
        action join_round(r:round_t) = {
            current_round := r;
            call abs_paxos.join_round(self, r); # ghost
            call control_intf(self).notify_changed_round(current_round);
            
            # reset round data for new round.
            leader_ready := false;
            leadership_acquired := false;
            inst_status := ballot_status_array.empty;
        }
        
        import action debug_vote(m:msg)
        action vote(leader:node, i:inst_t, v:value_t) = { # TODO: why update inst_status? If only the leader tracks other's votes, there's no need
            # resize if needed:
            if my_votes.end <= i {
                my_votes := my_votes.resize(i.next, not_a_vote)
            };
            var new_vote:vote_struct;
            new_vote.rnd := current_round;
            new_vote.val := v;
            new_vote.present := true;
            my_votes := my_votes.set(i,new_vote);
            
            call abs_paxos.cast_vote(self, i, current_round, v); # ghost
            
            # broadcast votes if broadcast_votes is true
            var m2:msg := build_vote_msg(i, v);
            call shim.unicast(self, leader, m2);
            call debug_vote(m2)
        }

        action build_vote_msg(i:inst_t, v:value_t) returns (m:msg) = {
            m.m_kind := msg_kind.two_b;
            m.m_round := current_round;
            m.m_node := self;
            m.m_inst := i;
            m.m_value := v;
        }

        action build_decide_msg(i:inst_t) returns (m:msg) = {
            m.m_kind := msg_kind.decide;
            m.m_inst := i;
            m.m_round := current_round;
            m.m_value := my_log.get(i).decision;
            m.m_node := self;
        }

        # update first_undecided to the the next hole in the log.
        action update_first_undecided(i:inst_t) = {
            if (i = first_undecided) {
                var continue:bool := true;
                while i <= my_log.end & continue
                invariant i <= my_log.end
                invariant first_undecided <= i
                {
                    if ~is_decided(i) {
                        continue := false;
                    } else {
                        i := i.next;
                    }
                };
                first_undecided := i;
                call control_intf(self).notify_first_undecided(i);
            }
        }

        # Invariants:

        # decide messages        
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.decide & ~abs_paxos.decision(msg.m_inst(M),msg.m_value(M)))

        # keep-alive messages
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.keep_alive & current_round < msg.m_round(M) & leader_of(self, msg.m_round(M)))
        
        # round of a message:
        invariant ~(shim.sent(M,D) & (msg.m_kind(M) = msg_kind.one_a | msg.m_kind(M) = msg_kind.two_a | msg.m_kind(M) = msg_kind.one_b | msg.m_kind(M) = msg_kind.two_b) & msg.m_round(M) > model.current_round(msg.m_node(M)))
        
        # one_as are sent by leaders and one_bs to leaders
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_a & ~leader_of(msg.m_node(M),msg.m_round(M)))
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & ~leader_of(D,msg.m_round(M)))

        # next_inst bounds proposals
        invariant leader_of(self, current_round) & ~leadership_acquired -> ~abs_paxos.proposal(I, current_round, V)
        invariant ~(leader_of(self, current_round) & next_inst <= I & abs_paxos.proposal(I, current_round,V))
        # invariant leader_ready & leader_of(self, current_round) & next_inst <= I -> abs_paxos.available(current_round,I)
        
        # current_round bounds proposals and votes
        # invariant ~(leader_of(self,R) & (current_round < R | (R = current_round & ~leader_ready)) & abs_paxos.proposal(I,R,V))
        invariant ~(leader_of(self,R) & current_round < R & abs_paxos.proposal(I,R,V))
        invariant ~(abs_paxos.vote(self,I,R,V) & current_round < R)

        # left_round
        conjecture current_round = R & R <= R2 -> ~abs_paxos.left_round(self,R2)
        conjecture current_round = R & R2 < R -> abs_paxos.left_round(self,R2)
        
        # two_a messages
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.two_a & ~abs_paxos.proposal(msg.m_inst(M),msg.m_round(M),msg.m_value(M)))
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.two_a  & ~leader_of(msg.m_node(M),msg.m_round(M)))

        # two_b message
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.two_b & ~abs_paxos.vote(msg.m_node(M), msg.m_inst(M), msg.m_round(M), msg.m_value(M)))

        # inst_status
        invariant I < inst_status.end & inst_status.value(I).active -> abs_paxos.proposal(I, current_round, inst_status.value(I).proposal)
        invariant I < inst_status.end & nset.member(N,inst_status.value(I).voters) -> abs_paxos.vote(N,I,current_round,inst_status.value(I).proposal)

        # one_a messages
        invariant L = msg.m_node(M) & shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_a -> leader_of(L, msg.m_round(M)) # TODO: needed?
        invariant L = msg.m_node(M) & shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_a & model.current_round(L) = msg.m_round(M) & ~model.leader_ready(L) -> msg.m_inst(M) = model.first_undecided(L) # TODO: needed?
        
        # one_b messages
        invariant shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b -> (model.current_round(D) >= msg.m_round(M))
        invariant shim.sent(M,L) & msg.m_kind(M) = msg_kind.one_b & model.current_round(L) = msg.m_round(M) & ~model.leader_ready(L) -> msg.m_inst(M) = model.first_undecided(L) 
        invariant shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b -> msg.m_votes(M).begin(msg.m_inst(M)) 
        invariant shim.sent(M,L) & msg.m_kind(M) = msg_kind.one_b & msg.m_inst(M) <= I & msg.m_votes(M).value(I,S) & present(S) -> (abs_paxos.vote(msg.m_node(M),I,rnd(S),val(S)) & (rnd(S) < R & R < msg.m_round(M) -> ~abs_paxos.vote(msg.m_node(M),I,R,V))) 
        invariant shim.sent(M,L) & msg.m_kind(M) = msg_kind.one_b & msg.m_inst(M) <= I & msg.m_votes(M).value(I,S) & ~present(S) & R < msg.m_round(M) -> ~abs_paxos.vote(msg.m_node(M),I,R,V)
        invariant shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b -> exists V . msg.m_votes(M).value(I,V)

        invariant leader_ready -> leadership_acquired

        # the joined_votes and joined data-structures
        relation recovering
        definition recovering = leader_of(self, current_round) & ~leader_ready
        invariant current_round ~= 0 & leadership_acquired -> nset.majority(joined)
        invariant recovering -> joined_votes.begin(first_undecided)
        #invariant recovering -> joined_votes.begin(first_undecided)
        invariant exists V . joined_votes.value(I,V)
        invariant recovering & first_undecided <= I & joined_votes.value(I,S) & present(S) ->  abs_paxos.proposal(I,rnd(S),val(S))
        invariant recovering & nset.member(N,joined) -> current_round <= model.current_round(N)
        invariant recovering & first_undecided <= I & joined_votes.value(I,S) & present(S) & rnd(S) < R & R < current_round & nset.member(N,joined) ->  ~abs_paxos.vote(N,I,R,V)
        invariant recovering & first_undecided <= I & joined_votes.value(I,S) & ~present(S) & nset.member(N,joined) & R < current_round -> ~abs_paxos.vote(N,I,R,V)

        # invariants with control interface
        invariant current_round = control_intf(self).current_round
        invariant leader_ready <-> control_intf(self).leader_ready
        invariant first_undecided = control_intf(self).first_undecided
        invariant control_intf(self).leadership_acquired <-> leadership_acquired
        invariant (leadership_acquired | leader_ready) -> leader_of(self, current_round)
        invariant leadership_acquired & current_round ~= 0 -> (joined_votes.end(I) <-> I = control_intf(self).repropose_bound)
        invariant leadership_acquired & ~leader_ready -> next_inst = control_intf(self).next_inst
        
        # the votes array (which represent the node's own votes)
        invariant I < my_votes.end() & my_votes.present(I) -> (my_votes.rnd(I) <= current_round & abs_paxos.vote(self, I, my_votes.rnd(I), my_votes.val(I)) & (my_votes.rnd(I) < R -> ~abs_paxos.vote(self,I,R,V)))
        invariant (I >= my_votes.end | (I < my_votes.end() & ~my_votes.present(I))) -> ~abs_paxos.vote(self,I,R,V)
        invariant first_undecided <= my_log.end
        
        # decisions:
        invariant ~(I < my_log.end & my_log.value(I).done & ~abs_paxos.decision(I, my_log.value(I).decision))

        #  next_inst in normal case
        invariant leader_of(self, current_round) & leader_ready & nset.member(N, joined) -> model.current_round(N) >= current_round
        invariant leader_of(self, current_round) & leader_ready & current_round ~= 0 -> nset.majority(joined)
        invariant leader_of(self, current_round) & leader_ready & next_inst <= I & nset.member(N, joined) & R < current_round -> (~abs_paxos.vote(N,I,R,V) & abs_paxos.left_round(N,R))
        
    }


    instance time : unbounded_sequence
    instance timearray : array(inst_t, time)

    object controller(self:node) = {

        relation leader_ready
        individual current_round:round_t
        individual first_undecided:inst_t
        individual repropose_bound:inst_t

        invariant current_round = control_intf(self).current_round
        invariant first_undecided = control_intf(self).first_undecided

        after init {
            current_round := 0;
            leader_ready := leader_of(self, 0);
            first_undecided := 0;
        }

        implement control_intf.notify_first_undecided(i:inst_t) {
            first_undecided := i
        }

        implement control_intf.notify_leadership_acquired(begin:inst_t, end:inst_t) {
            first_undecided := begin;
            repropose_bound := end;
            if (first_undecided < end) {
                var i := first_undecided;
                while (i < end)
                invariant i <= end
                invariant first_undecided <= i
                invariant i = control_intf(self).next_inst
                {
                    call control_intf.propose_highest_or_noop(self, i);
                    i := i.next
                }
            };
            call control_intf(self).activate_round;
        }

        object timer = {
            # timeout_sec is a standard module that calls timeout every second:
            instance sec : timeout_sec
            implement sec.timeout { # every second
                call leader_election.tick;
                call two_a_retransmitter.tick;
            }
        }

        # object that starts new rounds when timing out on the leader and sends heartbeat messages when self is a leader.
        object leader_election = {
            
            individual my_time : time
            individual last_heard_from_leader : time
            individual last_start_round : time
            individual timeout : time

            after init {
                my_time := 0;
                last_heard_from_leader := 0;
                last_start_round := 0;
                timeout := 3; # timeout on the leader after 3 seconds
            }

            implement control_intf.notify_keep_alive {
                last_heard_from_leader := my_time; 
            }

            implement control_intf.notify_changed_round(r:round_t) {
                if (leader_of(self,r)) {
                    last_start_round := my_time
                };
                last_heard_from_leader := my_time;
                current_round := r
            }
            
            action debug_tick(t:time, b:bool)
            import debug_tick

            action tick = {
                my_time := my_time.next; # update local time
                #call debug_tick(my_time, leader_of(self,current_round));

                if (~leader_of(self,current_round)) {
                    if my_time - last_heard_from_leader >= timeout {
                        call control_intf(self).timed_out_on_leader;
                        last_heard_from_leader := my_time;
                    }
                }
                else { # self is leader of the current round
                    call control_intf(self).send_keep_alive;
                    last_heard_from_leader := my_time;
                }
            }
        }

        # periodically, the leader retransmits two_a messages for pending instances that were started more than 1 second ago:
        object two_a_retransmitter = {
            individual two_a_times:timearray
            individual current_time:time
            individual last_started:inst_t
            # TODO:
            #invariant first_undecided <= last_started

            after init {
                current_time := 0;
                two_a_times := timearray.empty;
                last_started := 0;
            }
            
            implement control_intf.notify_two_a(i:inst_t) {
                if (last_started < i) {
                    last_started := i
                };
                if (two_a_times.end <= i) {
                    two_a_times := two_a_times.resize(i.next,0)
                };
                two_a_times := two_a_times.set(i,current_time)
            }

            # implement control_intf.notify_decision(i:inst_t) {
            # }
            
            action tick = {
                if (leader_of(self, current_round) & leader_ready) {
                    var i:inst_t := first_undecided;
                    var bound:inst_t := last_started.next;
                    if (i < bound) { # TODO: eliminate this with invariant above
                        while (i < bound)
                        invariant i <= bound
                        {
                            call control_intf(self).retransmit_two_a(i);
                            i := i.next;
                        };
                    };
                };
                current_time := current_time.next
            }
        }
    }

    isolate iso_model = model with control_intf, nset, votemap, abs_paxos, round_leader, round_t, shim, inst_t, not_a_vote_def, ballot_status_array, status_initialization, log, no_decision_initialization, win, geq_def 
    isolate iso_controller = controller with control_intf, inst_t, time, timearray
    isolate iso_control_intf = control_intf
    isolate iso_server = server with abs_paxos.agreement
    
} with system.model, system.controller, shim, abs_paxos, nset


#export system.server.propose
#export system.server.query
import system.server.decide

isolate impl_defs = {
    interpret value_t -> strlit
    definition no_op = "" 
    definition round_leader.leader_fun(r:round_t) = <<< r % `node.size` >>>
}

extract code(self:node) = nset, node, system, system.server(self), system.model(self), system.controller(self), system.control_intf(self), shim(self), net(self), inst_t, round_t, votemap, round_leader, impl_defs, not_a_vote_def, win, geq_def
