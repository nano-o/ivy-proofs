#lang ivy1.7

# This file contains an implementation of the Multi-Paxos protocol (without log truncation).
# The specification of the client interface appears in the specification block of the server object.

include timeout # from standard library

include multi_paxos_protocol
include network_shim_tcp

# Every round has a leader. We represent this with the inverse
# functional relation `leader_of`. If we use the spec of this
# isolate, we get just the injectivity property, whereas the
# impl also gives us totality.
relation leader_of(N:node, E:round_t)
isolate round_leader = {
    action get_leader(r:round_t) returns (n:node)
    action get_next_round(r:round_t, n:node) returns (s:round_t)
    specification {
        property [injectivity] leader_of(Y,X) & leader_of(Z,X) -> Y = Z
        after get_leader {
            ensure leader_of(n,r)
        }
        after get_next_round {
            ensure r < s & leader_of(n,s)
        }
    }
    implementation {
        function leader_fun(R:round_t) : node
        definition leader_of(N,R) = (N = leader_fun(R))
        implement get_leader(r:round_t) {
            n := leader_fun(r)
        }
        implement get_next_round {
            var iter := r.next;
            while ~leader_of(n,iter)
            invariant r < iter
            {
                iter := iter.next
            };
            s := iter;
        }
    }
} with round_t

# no_ops to fill holes in the log
individual no_op : value_t

# Multi-Paxos implementation
isolate system = {
    
    type ballot_status = struct {
        active : bool,
        voters : nset,
        proposal : value_t,
        decided : bool
    }
    instance ballot_status_array : array(inst_t, ballot_status)
    individual init_status : ballot_status
    # default status for initialization
    object status_obj = {
        invariant ~init_status.decided & ~nset.member(N,init_status.voters) & ~init_status.active
        after init {
            init_status.active := false;
            init_status.decided := false;
            init_status.voters := nset.emptyset();
        }
    }

    type decision_struct = struct {
        decision: value_t,
        present: bool
    }
    
    instance log : array(inst_t, decision_struct)
    
    individual no_decision : decision_struct
    object no_decision_initialization = {
        after init {
            no_decision.present := false
        }
        invariant ~no_decision.present
    }   

    object server(self:node) = {

        # API for client code:
        # returns false and does nothing if called on a node where leader_of(self,current_round)=false or current_round is not yet active.
        action propose(v:value_t) returns (r:bool)

        # called by the client to query the log
        action query(i:inst_t) returns (d:decision_struct)

        # called by server to report a decision
        action decide(i:inst_t,v:value_t)

        # the service specification:
        # do not change; the key-value store shim depends on this interface
        specification {
            
            relation decided(S:inst_t,V:value_t)

            object spec_init = {
                after init {
                    decided(I,V) := false;
                }
            }

            # agreement:
            after decide {
                decided(i,v) := true;
                ensure server.decided(N,i,V) -> V = v;
            }

            after query {
                ensure d.present -> decided(i,d.decision)
            }
        }
    }

    # Interface between model and controller. 

    object control_intf(self:node) = {

        # Calls from controller to model

        # propose an instance that is waiting
        # action propose_waiting(i : inst_t) 

        # propose an instance during recovery
        # action propose_safe_val(i : inst_t)

        # retransmit two_a message for a pending instance
        action retransmit_two_a(i : inst_t)
        
        # ask for a missing (undecided) instance
        # action ask_missing(i:inst_t)

        # leader sends a keep_alive message
        action send_keep_alive

        # start a new round
        action start_new_round

        # Calls from model to controller

        action notify_decision(i:inst_t)

        action notify_two_a(i:inst_t)

        action notify_changed_round(r:round_t)

        action notify_keep_alive

        individual current_round:round_t

        specification {

            after init {
                current_round := 0;
            }
            before send_keep_alive {
                assert leader_of(self, current_round)
            } 
            before notify_changed_round {
                current_round := r
            }
            before retransmit_two_a {
                assert leader_of(self, current_round)
            } 
        }
    }

    object model(self:node) = {
        
        individual current_round : round_t
        individual next_inst : inst_t # next free consensus instance 
        individual inst_status : ballot_status_array # votes received in the current round, per instance
        individual my_log : log # the decision log
        individual first_undecided : inst_t # the first "hole" in the log
        # data structures used upon leadership change:
        relation round_active # true when successfully acquired leadership
        individual my_votes : votemap # max votes by self.
        individual joined: nset # the set of nodes that joined the current round so far

        function is_decided(J:inst_t):bool
        definition is_decided(J:inst_t) = (J < my_log.end & my_log.value(J).present)

        after init {
            current_round := 0;
            next_inst := 0;
            my_votes := votemap.empty;
            joined := nset.emptyset();
            #joined_votes := votemap_seg.empty;
            round_active := leader_of(self,0);
            inst_status := ballot_status_array.empty;
            my_log := log.empty;
            first_undecided := 0;
        }
        

        ################################################################################
        # Here, we implement the server side of the client API

        implement server.query(i:inst_t) {
            if is_decided(i) {
                d.decision := my_log.value(i).decision;
                d.present := true;
            }
            else d.present := false;
        }


        implement server.propose(v:value_t) returns (ret:bool) {
            if leader_of(self, current_round) & round_active & current_round = 0 { # TODO
                call abs_paxos.propose(next_inst, current_round, v, 0); # TODO
                var m:msg := build_proposal(next_inst,v);
                call shim.bcast(self,m);
                call control_intf(self).notify_two_a(next_inst);
                
                call vote(self, next_inst, v);

                if (inst_status.end <= next_inst) {
                    inst_status := inst_status.resize(next_inst.next, init_status);
                };
                var status:ballot_status := inst_status.get(next_inst);
                status.active := true;
                status.proposal := v;
                
                next_inst := inst_t.next(next_inst);
                ret := true;
            }
            else {
                ret := false;
            }
        }


        ################################################################################
        # Here, we implement the handler side of the network interface

        implement shim.one_a_handler.handle(m:msg) {
            if current_round < m.m_round {
                call change_round(m.m_round);
                var m2:msg;
                m2.m_kind := msg_kind.one_b;
                m2.m_round := m.m_round;
                m2.m_node := self;
                #m2.m_votes := TODO;
                var leader:node := m.m_node;
                call shim.unicast(self,leader,m2);
            };
        }

        implement shim.one_b_handler.handle(m:msg) {
            if current_round = m.m_round & ~round_active {
                joined := joined.add(m.m_node);
            }; 

            # TODO: activate round
            # if joined.majority {
            #     round_active := true;
            # }
        }
        
        # receiving a proposal:
        implement shim.two_a_handler.handle(m:msg) {
            if (current_round <= m.m_round) {
                if (current_round < m.m_round) {
                    call change_round(m.m_round);
                };

                if (~is_decided(m.m_inst) & ~leader_of(self, current_round)) { # Note here the leader may be receiving its own proposal, but it already voted
                    call vote(m.m_node, m.m_inst, m.m_value);
                }
                else if (m.m_node ~= self) {
                    # TODO: send decide message
                    # var m2:msg := build_decide_msg(m.m_inst);
                    # call shim.unicast(self, m.m_node, m2);
                };

                if (first_undecided < m.m_inst) {
                    #call ask_for_retransmission(m.m_inst);
                }
            }
        }

        implement shim.decide_handler.handle(m:msg) {
            if (~is_decided(m.m_inst)) {
                if (inst_status.size <= m.m_inst.next) {
                    inst_status := inst_status.resize(m.m_inst.next,init_status);
                };
                if (my_log.size <= m.m_inst.next) {
                    my_log := my_log.resize(m.m_inst.next,no_decision);
                };
                var d: decision_struct;
                d.present := true;
                d.decision := m.m_value;
                my_log := my_log.set(m.m_inst,d);
                
                call update_first_undecided(m.m_inst);
                
                var status := inst_status.get(m.m_inst);
                status.decided := true;
                inst_status := inst_status.set(m.m_inst,status);
                
                call server(self).decide(m.m_inst,m.m_value);
            }
        }
        
        action debug_two_b_handler(a:bool)
        import debug_two_b_handler
        # receiving a vote:
        implement shim.two_b_handler.handle(m:msg) {
            # first make sure that inst_status is big enough.
            if (inst_status.size <= m.m_inst.next) {
                inst_status := inst_status.resize(m.m_inst.next,init_status);
            };
            
            var status := inst_status.get(m.m_inst);
            if status.active & ~status.decided & m.m_round = current_round {
                status.voters := status.voters.add(m.m_node);
                if status.voters.majority {
                    call debug_two_b_handler(status.active);
                    status.decided := true;
                    
                    # update local log:
                    if (my_log.size <= m.m_inst.next) {
                        my_log := my_log.resize(m.m_inst.next,no_decision);
                    };
                    var d: decision_struct;
                    d.present := true;
                    d.decision := m.m_value;
                    my_log := my_log.set(m.m_inst,d);

                    call update_first_undecided(m.m_inst);

                    var m2:msg := build_decide_msg(m.m_inst);
                    call shim.bcast(self,m2);

                    call abs_paxos.decide(m.m_inst, m.m_round, m.m_value, status.voters); # ghost
                    call server(self).decide(m.m_inst, m.m_value);
                };
                inst_status := inst_status.set(m.m_inst,status)
            }
        }

        implement shim.keep_alive_handler.handle(m:msg) {
            var r := m.m_round;
            if current_round < r {
                call change_round(r);
            };
        }

        ################################################################################
        # Here we implement the model side of the controller/model interface

        # called when timing out on the current leader:
        implement control_intf.start_new_round {
            call change_round(next_self_leader_round(current_round));
            # self joins the current round:
            joined := joined.add(self);

            # broacast one_a
            var m:msg;
            m.m_kind := msg_kind.one_a;
            m.m_round := current_round;
            m.m_node := self;
            m.m_inst := first_undecided; # here we request only instances after the first undecided instance.
            call shim.bcast(self,m);
        }

        implement control_intf.retransmit_two_a(i:inst_t) {
            if i < inst_status.end & inst_status.value(i).active & ~inst_status.value(i).decided {
                var m:msg;
                m.m_kind := msg_kind.two_a;
                m.m_node := self;
                m.m_round := current_round;
                m.m_inst := i;
                m.m_value := inst_status.value(i).proposal;
                call shim.bcast(self, m);
                call control_intf(self).notify_two_a(i);
            }
        }

        implement control_intf.send_keep_alive {
            var m : msg;
            m.m_kind := msg_kind.keep_alive;
            m.m_round := current_round;
            m.m_node := self;
            call shim.bcast(self,m);
        }

        ################################################################################
        # Here we have internal actions


        action build_proposal(j:inst_t, v:value_t) returns (m:msg) = {
            m.m_kind := msg_kind.two_a;
            m.m_round := current_round;
            m.m_node := self;
            m.m_inst := j;
            m.m_value := v;
        }

        # TODO: wrap in an object to expose only a spec?
        action next_self_leader_round(r:round_t) returns (s:round_t) = {
            # find the next round in which self is leader
            var iter := current_round.next;
            while ~leader_of(self,iter)
            invariant current_round < iter
            {
                iter := iter.next
            };
            s := iter;
        }
        
        action change_round(r:round_t) = {
            current_round := r;
            call abs_paxos.join_round(self, r); # ghost
            call control_intf(self).notify_changed_round(current_round);
            
            round_active := false;
            # reset round data for new round.
            inst_status := ballot_status_array.empty;
            joined := nset.emptyset();
        }
        
        action debug_vote(m:msg)
        import debug_vote
        action vote(leader:node, i:inst_t, v:value_t) = {
            # resize if needed:
            if my_votes.end <= i {
                my_votes := my_votes.resize(i.next, not_a_vote)
            };
            if inst_status.end <= i {
                inst_status := inst_status.resize(i.next, init_status)
            };
            
            var new_vote:vote_struct;
            new_vote.rnd := current_round;
            new_vote.val := v;
            new_vote.present := true;
            my_votes := my_votes.set(i,new_vote);
            
            var status := inst_status.get(i);
            status.voters := status.voters.add(self);
            status.proposal := v;
            status.active := true;
            inst_status := inst_status.set(i,status);
            
            call abs_paxos.cast_vote(self, i, current_round, v); # ghost
            
            # broadcast votes if broadcast_votes is true
            var m2:msg := build_vote_msg(i, v);
            call shim.unicast(self, leader, m2);
            call debug_vote(m2)
        }

        action build_vote_msg(i:inst_t, v:value_t) returns (m:msg) = {
            m.m_kind := msg_kind.two_b;
            m.m_round := current_round;
            m.m_node := self;
            m.m_inst := i;
            m.m_value := v;
        }

        action build_decide_msg(i:inst_t) returns (m:msg) = {
            m.m_kind := msg_kind.decide;
            m.m_inst := i;
            m.m_round := current_round;
            m.m_value := my_log.get(i).decision;
            m.m_node := self;
        }

        # update first_undecided to the the next hole in the log.
        action update_first_undecided(i:inst_t) = {
            if (i = first_undecided) {
                var continue:bool := true;
                while i <= my_log.end & continue
                invariant i <= my_log.end
                {
                    if ~is_decided(i) {
                        continue := false;
                    } else {
                        i := i.next;
                    }
                };
                first_undecided := i
            }
        }

        # Invariants:

        # # round 0:
        # invariant ~(abs_paxos.vote(N,I,R,V) & R = 0)
        # invariant ~(next_inst ~= 0 & current_round = 0)

        # decide messages        
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.decide & ~abs_paxos.decision(msg.m_inst(M),msg.m_value(M)))

        # keep-alive messages
        invariant current_round = control_intf(self).current_round
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.keep_alive & current_round < msg.m_round(M) & leader_of(self, msg.m_round(M)))
        
        # round of a message:
        invariant ~(shim.sent(M,D) & (msg.m_kind(M) = msg_kind.one_a | msg.m_kind(M) = msg_kind.two_a | msg.m_kind(M) = msg_kind.one_b | msg.m_kind(M) = msg_kind.two_b) & msg.m_round(M) > model.current_round(msg.m_node(M)))
        
        # current_round and active:
        # invariant leader_of(self, current_round) -> (round_active <-> abs_paxos.active(current_round))
        # invariant ~(leader_of(self, R) & abs_paxos.active(R) & R > current_round)
        # invariant ~(leader_of(self, current_round) & round_active & ~abs_paxos.active(current_round))

        # one_as are sent by leaders
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_a & ~leader_of(msg.m_node(M),msg.m_round(M)))
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & ~leader_of(D,msg.m_round(M)))

        # next_inst bounds proposals
        invariant ~(leader_of(self, current_round) & next_inst <= I & abs_paxos.proposal(I, current_round,V))
        # invariant round_active & leader_of(self, current_round) & next_inst <= I -> abs_paxos.available(current_round,I)
        
        # current_round bounds proposals and votes
        invariant ~(leader_of(self,R) & (current_round < R | (R = current_round & ~round_active)) & abs_paxos.proposal(I,R,V))
        invariant ~(abs_paxos.vote(self,I,R,V) & current_round < R)

        # left_round
        conjecture current_round = R & R <= R2 -> ~abs_paxos.left_round(self,R2)
        conjecture current_round = R & R2 < R -> abs_paxos.left_round(self,R2)
        
        # two_a messages
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.two_a & ~abs_paxos.proposal(msg.m_inst(M),msg.m_round(M),msg.m_value(M)))
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.two_a  & ~leader_of(msg.m_node(M),msg.m_round(M)))

        # two_b message
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.two_b & ~abs_paxos.vote(msg.m_node(M), msg.m_inst(M), msg.m_round(M), msg.m_value(M)))

        # inst_status
        invariant ~(I < inst_status.end & inst_status.value(I).active & ~abs_paxos.proposal(I, current_round, inst_status.value(I).proposal))
         invariant ~(I < inst_status.end & nset.member(N,inst_status.value(I).voters) & ~abs_paxos.vote(N,I,current_round,inst_status.value(I).proposal))

        # one_a messages
        # invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_a & model.current_round(msg.m_node(M)) = msg.m_round(M) & ~model.round_active(msg.m_node(M)) & msg.m_inst(M) ~= model.joined_votes(msg.m_node(M)).first)
        
        # one_b messages
        invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & model.current_round(D) < msg.m_round(M))
        # invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & msg.m_votemap(M).upper < msg.m_votemap(M).first)
        # invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & model.current_round(D) = msg.m_round(M) & ~model.round_active(D) & msg.m_votemap(M).first ~= model.joined_votes(D).first)
        # invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & msg.m_votemap(M).first <= I & votemap_seg_ops.maxvote(msg.m_votemap(M),I).rnd = none & R < msg.m_round(M) & abs_paxos.vote(msg.m_node(M), I, R, V))
        # invariant ~(shim.sent(M,D) & msg.m_kind(M) = msg_kind.one_b & msg.m_votemap(M).first <= I & MAXR = votemap_seg_ops.maxvote(msg.m_votemap(M),I).rnd & MAXR ~= 0 & (~abs_paxos.vote(msg.m_node(M), I, MAXR, votemap_seg_ops.maxvote(msg.m_votemap(M),I).val) | (R > MAXR & R < msg.m_round(M) & abs_paxos.vote(msg.m_node(M), I, R, V))))

        # #  the joined_votes and joined data-structures
        # invariant ~(leader_of(self, current_round) & ~round_active & joined_votes.upper < joined_votes.first)
        # invariant ~(leader_of(self, current_round) & ~round_active & joined_votes.first <= I & votemap_seg_ops.maxvote(joined_votes,I).rnd = none & nset.member(N,joined) & R < current_round & abs_paxos.vote(N,I,R,V))
        # invariant ~(leader_of(self, current_round) & ~round_active & joined_votes.first <= I & votemap_seg_ops.maxvote(joined_votes,I).rnd ~= none & nset.member(N,joined) & (votemap_seg_ops.maxvote(joined_votes,I).rnd < R & R < current_round & abs_paxos.vote(N,I,R,V)))
        # invariant ~(current_round ~= 0 & leader_of(self, current_round) & joined_votes.first <= I & votemap_seg_ops.maxvote(joined_votes,I).rnd ~= 0 & ~abs_paxos.proposal(I,votemap_seg_ops.maxvote(joined_votes,I).rnd,votemap_seg_ops.maxvote(joined_votes,I).val))
        # invariant ~(leader_of(self, current_round) & nset.member(N,joined) & ~abs_paxos.joined_round(N,current_round))

        # the votes array (which represent the node's own votes)
        invariant I < my_votes.end() & my_votes.present(I) -> (my_votes.rnd(I) <= current_round & abs_paxos.vote(self, I, my_votes.rnd(I), my_votes.val(I)) & (my_votes.rnd(I) < R -> ~abs_paxos.vote(self,I,R,V)))
        
        # decisions:
        invariant server(self).decided(I,V) -> abs_paxos.decision(I,V)
        invariant ~(I < my_log.end & my_log.value(I).present & ~server(self).decided(I,my_log.value(I).decision))
        
    }


    instance time : unbounded_sequence
    instance timearray : array(inst_t, time)

    object controller(self:node) = {

        individual round_active:bool
        individual current_round:round_t

        invariant current_round = control_intf(self).current_round

        after init {
            current_round := 0;
            round_active := leader_of(self, 0);
        }

        object timer = {
            # timeout_sec is a standard module that calls timeout every second:
            instance sec : timeout_sec
            implement sec.timeout { # every second
                call leader_election.tick;
                call two_a_retransmitter.tick;
            }
        }

        # object that starts new rounds when timing out on the leader and sends heartbeat messages when self is a leader.
        object leader_election = {
            
            individual my_time : time
            individual last_heard_from_leader : time
            individual last_start_round : time
            individual timeout : time

            action increase_time
            action is_leader_too_quiet returns (res: bool)
            action start_round_timed_out returns (res: bool)
            
            after init {
                my_time := 0;
                last_heard_from_leader := 0;
                last_start_round := 0;
                timeout := 3;
            }

            implement control_intf.notify_keep_alive {
                last_heard_from_leader := my_time; 
            }

            implement control_intf.notify_changed_round(r:round_t) {
                if (leader_of(self,r)) {
                    last_start_round := my_time
                };
                last_heard_from_leader := my_time;
                current_round := r
            }
            
            implement start_round_timed_out {
                res := my_time - last_start_round >= timeout
            }
            implement is_leader_too_quiet {
                res := my_time - last_heard_from_leader >= timeout
            }
            
            # action debug_tick(t:time, b:bool)
            # import debug_tick

            action tick = {
                my_time := my_time.next;
                #call debug_tick(my_time, leader_of(self,current_round));
                if (~leader_of(self,current_round)) {
                    if is_leader_too_quiet {
                        call control_intf(self).start_new_round
                    }
                }
                else {
                    if ~round_active {
                        if start_round_timed_out {
                            call control_intf(self).start_new_round
                        }
                    } else {
                        call control_intf(self).send_keep_alive
                    }
                }
            }
        }

        # periodically, the leader retransmits two_a messages for pending instances that were started more than 1 second ago:
        object two_a_retransmitter = {
            individual two_a_times:timearray
            individual current_time:time
            individual last_started:inst_t
            individual first_undecided:inst_t

            after init {
                current_time := 0;
                two_a_times := timearray.empty;
                last_started := 0;
                first_undecided := 0;
            }
            
            implement control_intf.notify_two_a(i:inst_t) {
                if (last_started < i) {
                    last_started := i
                };
                if (two_a_times.end <= i) {
                    two_a_times := two_a_times.resize(i.next,0)
                };
                two_a_times := two_a_times.set(i,current_time)
            }
            
            action tick = {
                if (leader_of(self, current_round) & round_active) {
                    var i:inst_t := 0; # TODO: should be first_undecided;
                    while (i < last_started)
                    invariant i <= last_started
                    {
                        call control_intf(self).retransmit_two_a(i);
                        i := i.next;
                    };
                };
                current_time := current_time.next
            }
        }
    }

    isolate iso_model = model with server, control_intf, nset, votemap, abs_paxos, round_leader, round_t, shim, inst_t, not_a_vote_def, ballot_status_array, status_obj, log, no_decision_initialization, win

    isolate iso_controller = controller with control_intf, inst_t, time, timearray

} with system.model, system.controller, shim, abs_paxos, nset

export system.server.propose
export system.server.query
import system.server.decide

object impl_defs = {
    interpret value_t -> strlit
    definition no_op = "" 
    definition round_leader.leader_fun(r:round_t) = <<< r % `node.size` >>>
}

extract code(self:node) = nset, node, system, system.server(self), system.model(self), system.controller(self), system.control_intf(self), shim(self), net(self), inst_t, round_t, votemap, round_leader, impl_defs, not_a_vote_def, win

# to check: run "ivy_check multi_paxos_system.ivy"
# to check only the system isolate: run "ivy_check isolate=system multi_paxos_system.ivy"
# to check only the protocol isolate: run "ivy_check isolate=protocol multi_paxos_system.ivy"
