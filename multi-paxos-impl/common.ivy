#lang ivy1.7

include collections
include order
include nodes
include my_window_adt

instance round_t : unbounded_sequence
instance inst_t : unbounded_sequence # instances, i.e. positions in the log
type value_t

type vote_struct = struct {
   rnd : round_t,
   val: value_t,
   present : bool 
}

individual not_a_vote : vote_struct
trusted isolate not_a_vote_def = {
     specification {
         invariant not_a_vote.present = false
     }
    implementation { # TODO: dirty hack to prevent Ivy from tryin to find a value for not_a_vote by getting a model (which diverges)
        definition not_a_vote = <<< (vote_struct){.rnd=0,.val="",.present=false} >>>
    }
}

object votemap = {
    instantiate array(inst_t, vote_struct)

    function val(M:t,I:inst_t):value_t
    definition val(M,I) = value(M,I).val

    function rnd(M:t,I:inst_t):round_t
    definition rnd(M,I) = value(M,I).rnd

    function present(M:t,I:inst_t):bool
    definition present(M,I) = value(M,I).present
}

function rank(S:vote_struct):round_t
definition rank(S:vote_struct) = rnd(S)

instance win : my_window(inst_t, vote_struct, not_a_vote, votemap, rank, round_t)

# export win.set
# export win.read
# export win.trim
# export win.empty
# export win.getBegin
# export win.getEnd
# export win.make
# export win.make_from_array
# export win.zip_max
