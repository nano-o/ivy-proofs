#lang ivy1.7

include collections
include order
include nodes
include my_window_adt

instance round_t : unbounded_sequence
instance inst_t : unbounded_sequence # instances, i.e. positions in the log
type value_t

object vote_struct = {
    type this
    function rnd(S:this) : round_t
    function val(S:this): value_t
    relation present(S:this)
    function geq(S1:this, S2:this):bool
    definition geq(S1:this, S2:this) = ~present(S2) | (present(S1) & rnd(S1) >= rnd(S2))
}

individual not_a_vote : vote_struct
trusted isolate not_a_vote_def = {
     specification {
         invariant not_a_vote.present = false
     }
    implementation { # TODO: dirty hack to prevent Ivy from tryin to find a value for not_a_vote by getting a model (which diverges)
        definition not_a_vote = <<< (vote_struct){.rnd=0,.val="",.present=false} >>>
    }
}

object votemap = {
    instantiate array(inst_t, vote_struct)

    function val(M:t,I:inst_t):value_t
    definition val(M,I) = value(M,I).val

    function rnd(M:t,I:inst_t):round_t
    definition rnd(M,I) = value(M,I).rnd

    function present(M:t,I:inst_t):bool
    definition present(M,I) = value(M,I).present
}

instance win : my_window(inst_t, vote_struct, not_a_vote, votemap, vote_struct)

# export win.set
# export win.read
# export win.trim
# export win.empty
# export win.getBegin
# export win.getEnd
# export win.make
# export win.make_from_array
# export win.zip_max
