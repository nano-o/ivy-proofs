#lang ivy1.7

include window_adt

module my_window(domain,range,none,arr_t,rank,rank_type) = { # TODO: renaming arr_t to arr causes mayhem becauase it clashes with arr defined in window_adt.ivy, but this is not detected as a problem by Ivy.
    instantiate window(domain,range,none)
    action make_from_array(i:domain, a:arr_t) returns (w:this)
    action zip_max(w1:this, w2:this) returns (res:this)

    specification {
        around make_from_array {
            require 0 <= i & i < a.end;
            ...
            ensure begin(w,I) <-> I = i;
            ensure i <= I & I < a.end & a.value(I) = V -> value(w, I, V);
            ensure (I < i | a.end <= I) -> (value(w, I, V) <-> V = none);
        }

        around zip_max {
            require exists I . begin(w1,I) & begin(w2,I)
            ...
            ensure value(w1,I,V1) & value(w2,I,V2) & rank(V2) > rank(V1) -> value(res,I,V2);
            ensure value(w1,I,V1) & value(w2,I,V2) & rank(V1) >= rank(V2) -> value(res,I,V1);
            # NOTE: this has a QA cycle:
            # ensure (exists B . begin(w1,B) & B <= I) & rank(w2,I) > rank(w1,I) -> forall V . map.value(res,I,V) <-> map.value(w2,I,V);
        }

    }
    implementation {
        implement make_from_array {
            w := empty(i);
            var j := i;
            while (j < a.end)
            invariant i <= j
            invariant j <= a.end
            invariant i <= J & J < j -> w.value(J,a.value(J))
            invariant w.begin(i)
            invariant j <= J -> w.value(J,none)
            {
                w := w.set(j, a.value(j));
                j := j.next;
            }
        }

        implement zip_max {
            var b := w1.getBegin;
            var e:inst_t := w1.getEnd;
            if (w2.getEnd > w1.getEnd) {
                e := w2.getEnd;
            };
            res := w1;
            var i:domain := b;
            while i < e 
            invariant i <= e
            invariant b <= i
            invariant i <= I -> (value(res,I,V) <-> value(w1,I,V))
            invariant begin(res,b)
            invariant b <= I & I < i & value(w1,I,V1) & value(w2,I,V2) & rank(V2) > rank(V1) -> (value(res,I,V) <-> value(w2,I,V))
            invariant b <= I & I < i & value(w1,I,V1) & value(w2,I,V2) & rank(V1) >= rank(V2) -> (value(res,I,V) <-> value(w1,I,V))
            {
                if rank(read(w1,i)) < rank(read(w2,i)) {
                    res := res.set(i, read(w2,i));
                };
                i := i.next;
            }
        }
    }
    isolate window_iso = this with arr_t, domain, rank_type
}

# test


# include common
# function rank(S:vote_struct):round_t
# definition rank(S:vote_struct) = rnd(S)

# instance win : my_window(inst_t,vote_struct,not_a_vote,votemap, rank)

# export win.set
# export win.read
# export win.trim
# export win.empty
# export win.getBegin
# export win.getEnd
# export win.make
# export win.make_from_array
# export win.zip_max

# isolate test = win with votemap, inst_t, round_t

# interpret value_t -> strlit

# extract code = win, inst_t, not_a_vote_def, votemap, round_t
