#lang ivy1.7

include window_adt

module my_window(domain,range,none,arr_t,geq) = { # TODO: renaming arr_t to arr causes mayhem because it clashes with arr defined in window_adt.ivy, but this is not detected as a problem by Ivy.
    instantiate window(domain,range,none)
    action make_from_array(i:domain, a:arr_t) returns (w:this)
    action zip_max(w1:this, w2:this) returns (res:this)

    specification {
        around make_from_array {
            require 0 <= i;
            ...
            ensure begin(w,I) <-> I = i;
            ensure i <= I & I < a.end & a.value(I) = V -> value(w, I, V);
            ensure (I < i | a.end <= I) -> (value(w, I, V) <-> V = none);
            ensure exists V . value(w,I,V)
        }

        around zip_max {
            require exists I . begin(w1,I) & begin(w2,I); # only zip windows that begin at the same position
            require exists V1,V2 . w1.value(I,V1) & w2.value(I,V2) # only work on well-formed windows
            ...
            ensure value(w1,I,V1) & value(w2,I,V2) & geq(V1,V2) -> value(res,I,V1);
            ensure value(w1,I,V1) & value(w2,I,V2) & ~geq(V1,V2) -> value(res,I,V2);
            ensure begin(res,I) <-> begin(w1,I);
            ensure exists V . value(res,I,V);
        }

    }
    implementation {
        implement make_from_array {
            w := empty(i);
            var j := i;
            if (j < a.end) {
                while (j < a.end)
                invariant i <= j
                invariant j <= a.end
                invariant i <= J & J < j -> w.value(J,a.value(J))
                invariant w.begin(i)
                invariant j <= J -> w.value(J,none)
                invariant exists V . w.value(I,V)
                {
                    w := w.set(j, a.value(j));
                    j := j.next;
                }
            }
        }

        implement zip_max {
            var b := w1.getBegin;
            var e:domain := w1.getEnd;
            if (w2.getEnd > w1.getEnd) {
                e := w2.getEnd;
            };
            res := w1;
            var i:domain := b;
            while i < e 
            invariant i <= e
            invariant b <= i
            invariant i <= I -> (value(res,I,V) <-> value(w1,I,V))
            invariant begin(res,b)
            invariant b <= I & I < i & value(w1,I,V1) & value(w2,I,V2) & ~geq(V1,V2) -> (value(res,I,V) <-> value(w2,I,V))
            invariant b <= I & I < i & value(w1,I,V1) & value(w2,I,V2) & geq(V1,V2) -> (value(res,I,V) <-> value(w1,I,V))
            invariant exists V . res.value(I,V)
            {
                if geq(read(w1,i), read(w2,i)) {
                    res := res.set(i, read(w2,i));
                };
                i := i.next;
            }
        }
    }
    isolate window_iso = this with arr_t, domain, elem_t
}

# test

# instance slot : unbounded_sequence
# instance data: unbounded_sequence

# instance arr : array(slot,data)

# individual rank(D:data):data
# definition rank(D:data) = D

# instance foo : my_window(slot,data,0,arr,rank,data)

# export foo.set
# export foo.read
# export foo.trim
# export foo.empty
# export foo.getBegin
# export foo.getEnd
# export foo.make
# export foo.make_from_array
# export foo.zip_max

# extract code = foo, slot, data, arr, this
