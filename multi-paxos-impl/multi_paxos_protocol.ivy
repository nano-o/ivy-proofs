#lang ivy1.7

# This file contains the specification and proof of a high-level, abstract version of the Multi-Paxos protocol.

include common

isolate abs_paxos = {

    relation left_round(N:node, R:round_t)
    relation proposal(I:inst_t, R:round_t, V:value_t)
    relation vote(N:node, I:inst_t, R:round_t, V:value_t)
    relation decision(I:inst_t, V:value_t)

    specification {

        after init {
            left_round(N,R) := false;
            proposal(I,R,V) := false;
            vote(N,I,R,V) := false;
            decision(I,V) := false;
        }
        
        invariant [agreement] decision(I,V1) & decision(I,V2) -> V1 = V2
        
        # proposals are unique per round
        invariant proposal(I,R,V1) & proposal(I,R,V2) -> V1 = V2

        # only vote for proposed values
        invariant vote(N,I,R,V) -> proposal(I,R,V)

        # we make the following invariants private because they have quantifier alternation which we do not want to expose outside this isolate
        private {
            # decisions come from quorums of votes:
            invariant decision(I,V) -> exists Q, R . nset.majority(Q) & forall N. nset.member(N, Q) -> vote(N,I,R,V)

            invariant nset.majority(Q) & R1 < R2 & proposal(I,R2,V2) & V1 ~= V2 -> (
                exists N:node. nset.member(N,Q) & left_round(N,R1) & ~vote(N,I,R1,V1)
            )
        }
        
        action join_round(n:node, r:round_t) = {
            require ~left_round(n,r);
            left_round(n,R) := left_round(n,R) | R < r;
        }
        
        action propose(i:inst_t, r:round_t, v:value_t, q:nset) = {
            require proposal(i, r, V) -> V = v;
            if (r ~= 0) { # everything is safe at 0
                require nset.majority(q);
                require nset.member(N, q) & R < r -> left_round(N,R);
                require forall N,R,V. ~(nset.member(N, q) & R < r & vote(N,i,R,V));
            };
            proposal(i, r, v) := true
        }

        action propose_recovery(i:inst_t, r:round_t, v:value_t, q:nset, maxr:round_t) = {
            require proposal(i, r, V) -> V = v;
            require r ~= 0; # just a sanity check, but wouldn't hurt
            require nset.majority(q);
            require nset.member(N, q) & R < r -> left_round(N,R);
            require 
                (forall N,R,V. ~(nset.member(N, q) & R < r & vote(N,i,R,V))) |
                (proposal(I, maxr, v) & (forall N,R,V.  ~(nset.member(N, q) & maxr < R & R < r & vote(N,i,R,V))));
            proposal(i, r, v) := true
        }

        action cast_vote(n:node, i:inst_t, r:round_t, v:value_t) = {
            require ~left_round(n,r);
            require proposal(i, r, v);
            vote(n, i, r, v) := true
        }

        action decide(i:inst_t, r:round_t, v:value_t, q:nset) = {
            require nset.majority(q);
            require nset.member(N, q) -> vote(N, i, r, v);
            decision(i, v) := true
        }
    }
}
with nset, nset.majorities_intersect, round_t, inst_t 

# test

# export abs_paxos.decide
# export abs_paxos.cast_vote
# export abs_paxos.propose
# export abs_paxos.join_round
