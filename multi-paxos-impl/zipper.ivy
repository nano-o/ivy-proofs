#lang ivy1.7

module zipper(index, none, rank, map) = {
    # TODO: zip windows instead of arrays...

    action zip_max(m1:map, m2:map) returns (res:map)

    specification {

        after zip_max {
            ensure (m2.end <= m1.end -> res.end = m1.end) & (m2.end > m1.end -> res.end = m2.end);
            ensure ~(I < m2.end & rank(m2,I) > rank(m1,I) & rank(res,I) ~= rank(m2,I));
            ensure ~(I < m2.end & rank(m2,I) <= rank(m1,I) & rank(res,I) ~= rank(m1,I));
            ensure ~(I >= m2.end & rank(res,I) ~= rank(m1,I));
        }
    }

    implementation {
        
        implement zip_max(m1:map, m2:map) returns (res:map) {
            res := m1;
            if (res.size < m2.size) {
                res := res.resize(m2.size, none);
            };
            var size := res.end;
            
            var i:index := 0;
            while i ~= m2.end
            invariant i <= m2.end
            invariant res.size = size
            invariant ~(I < i & rank(m2,I) <= rank(m1,I) & rank(res,I) ~= rank(m1,I))
            invariant ~(I < i & rank(m1,I) < rank(m2,I) & rank(res,I) ~= rank(m2,I))
            invariant ~(i <= I & rank(res,I) ~= rank(m1,I))
            {
                if rank(m1,i) < rank(m2,i) {
                    res := res.set(i, map.value(m2,i));
                };
                i := i.next;
            }
        }
        
    }
}

# test

# include common

# instance z : zipper(inst_t, not_a_vote, votemap.rnd, votemap)

# isolate z_iso = z with inst_t, not_a_vote, votemap

# extract code = z, inst_t, not_a_vote_def, votemap
